<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://pytorch.org/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://pytorch.org/" rel="alternate" type="text/html" />
  <updated>2023-01-30T12:56:47-08:00</updated>
  <id>https://pytorch.org/feed.xml</id>

  
  
  

  
    <title type="html">PyTorch Website</title>
  

  
    <subtitle>Scientific Computing...</subtitle>
  

  
    <author>
        <name>Facebook</name>
      
      
    </author>
  

  
  
  
    <entry>
      <title type="html">Accelerated Stable Diffusion with PyTorch 2</title>
      <link href="https://pytorch.org/blog/accelerated-stable-diffusion-2/" rel="alternate" type="text/html" title="Accelerated Stable Diffusion with PyTorch 2" />
      <published>2023-01-27T00:00:00-08:00</published>
      <updated>2023-01-27T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/accelerated-stable-diffusion-2</id>
      <content type="html" xml:base="https://pytorch.org/blog/accelerated-stable-diffusion-2/">&lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; PyTorch 2.0 nightly offers out-of-the-box performance improvement for Stable Diffusion 2.1 by using the new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile()&lt;/code&gt; compiler and optimized implementations of Multihead Attention integrated with PyTorch 2.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Stable Diffusion (SD) is a great example of Generative AI, producing high quality images from text prompts. However, as well as for other diffusion-based models, its generation is rather slow, due to the iterative nature of the sampling process by which the images are produced. This makes it important to optimize the code running inside the sampling loop.&lt;/p&gt;

&lt;p&gt;We took &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion&quot;&gt;SD 2.1 from Stability AI&lt;/a&gt; as a starting point and accelerated its text-to-image generation using two optimizations available in PyTorch 2: compilation and fast attention implementation. Together with a few minor memory processing improvements in the code these optimizations give up to 49% inference speedup relative to the original SD implementation without &lt;a href=&quot;https://github.com/facebookresearch/xformers&quot;&gt;xFormers&lt;/a&gt;, and 39% inference speedup relative to using SD with xFormers (excluding the compilation time), depending on the GPU architecture and batch size. Importantly, the speedup comes without a need to install xFormers or any other extra dependencies.&lt;/p&gt;

&lt;p&gt;The table below shows the improvement in runtime between the original implementation with xFormers installed and our optimized version with PyTorch-integrated memory efficient attention (originally developed for and released in the &lt;a href=&quot;https://github.com/facebookresearch/xformers&quot;&gt;xFormers&lt;/a&gt; library)  and PyTorch compilation. The compilation time is excluded.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime improvement in % compared to original+xFormers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;See the absolute runtime numbers in section &lt;a href=&quot;#benchmarking-setup-and-results-summary&quot;&gt;“Benchmarking setup and results summary”&lt;/a&gt;&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
&lt;thead&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;GPU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Batch size 1&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Batch size 2&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Batch size 4&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;P100 (no compilation)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;-3.8
   &lt;/td&gt;
   &lt;td&gt;0.44
   &lt;/td&gt;
   &lt;td&gt;5.47
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;T4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;2.12
   &lt;/td&gt;
   &lt;td&gt;10.51
   &lt;/td&gt;
   &lt;td&gt;14.2
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;A10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;-2.34
   &lt;/td&gt;
   &lt;td&gt;8.99
   &lt;/td&gt;
   &lt;td&gt;10.57
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;V100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;18.63
   &lt;/td&gt;
   &lt;td&gt;6.39
   &lt;/td&gt;
   &lt;td&gt;10.43
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;A100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;38.5
   &lt;/td&gt;
   &lt;td&gt;20.33
   &lt;/td&gt;
   &lt;td&gt;12.17
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;One can notice the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The improvements are significant for powerful GPUs like A100 and V100. For those GPUs the improvement is most pronounced for batch size 1&lt;/li&gt;
  &lt;li&gt;For less powerful GPUs we observe smaller speedups (or in two cases slight regressions). The batch size trend is reversed here: improvement is larger for larger batches&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the following sections we describe the applied optimizations and provide detailed benchmarking data, comparing SD performance with various optimization features on/off.&lt;/p&gt;

&lt;p&gt;Specifically, we benchmark 5 configurations and the plots below compare their absolute performance for different GPUs and batch sizes. For definitions of these configurations see section &lt;a href=&quot;#benchmarking-setup-and-results-summary&quot;&gt;“Benchmarking setup and results”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/stable-diffusion/summary_n_samples_1_n_iter_2_sd2.png&quot; alt=&quot;Benchmark of Stable Diffusion 2 versions across GPU architectures, batch size 1&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/stable-diffusion/summary_n_samples_2_n_iter_2_sd2.png&quot; alt=&quot;Benchmark of Stable Diffusion 2 versions across GPU architectures, batch size 2&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/stable-diffusion/summary_n_samples_4_n_iter_2_sd2.png&quot; alt=&quot;Benchmark of Stable Diffusion 2 versions across GPU architectures, batch size 4&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you prefer looking directly at the code, see the &lt;a href=&quot;https://colab.research.google.com/drive/1cSP5HoRZCbjH55MdYiRtxC_Q0obQQ5ZD?usp=sharing&quot;&gt;Google Colab&lt;/a&gt; which runs the benchmark on T4.&lt;/p&gt;

&lt;h2 id=&quot;optimizations&quot;&gt;Optimizations&lt;/h2&gt;

&lt;p&gt;Here we’ll go into more detail about the optimizations introduced into the SD code. At the moment they rely on features only available in the nightlies, so we pinned the PyTorch version to a recent nightly (see &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/blob/0f6d17cb2602302bc0f5c7dee6825e4b49a85518/environment.yaml#L13-L15&quot;&gt;here&lt;/a&gt;). Once the PyTorch 2.0 release comes out, these optimizations won’t have to rely on nightlies any more.&lt;/p&gt;

&lt;h3 id=&quot;optimized-attention&quot;&gt;Optimized Attention&lt;/h3&gt;

&lt;p&gt;One part of the code which we optimized was the scaled dot-product attention. Attention is known to be a heavy operation: naive implementation materializes the attention matrix, leading to time and memory complexity quadratic in sequence length. In Stable Diffusion attention (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt;) appears as part of Transformer blocks in multiple parts of the U-Net. Since the U-Net runs at every sampling step, this becomes a critical point to optimize. In PyTorch 2 optimized attention implementation is integrated into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.nn.MultiheadAttention&lt;/code&gt;, and so we used it to replace the &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/blob/d55bcd4d31d0316fcbdf552f2fd2628fdc812500/ldm/modules/attention.py#L145-L194&quot;&gt;custom attention implementation&lt;/a&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The optimized implementation of attention was available already in PyTorch 1.13 (see &lt;a href=&quot;https://pytorch.org/blog/a-better-transformer-for-fast-transformer-encoder-inference/&quot;&gt;here&lt;/a&gt;) and widely adopted (see e.g. &lt;a href=&quot;https://medium.com/pytorch/bettertransformer-out-of-the-box-performance-for-huggingface-transformers-3fbe27d50ab2&quot;&gt;HuggingFace transformers library example&lt;/a&gt;). In particular, it integrates memory-efficient attention from the &lt;a href=&quot;https://github.com/facebookresearch/xformers&quot;&gt;xFormers&lt;/a&gt; library and flash attention from &lt;a href=&quot;https://arxiv.org/abs/2205.14135&quot;&gt;https://arxiv.org/abs/2205.14135&lt;/a&gt;. PyTorch 2.0 expands this to additional attention functions such as cross attention and custom kernels for further acceleration, making it applicable to SD.&lt;/p&gt;

&lt;p&gt;Flash attention is available on GPUs with compute capability SM 7.5 or SM 8.x - for example, on T4, A10, and A100, which are included in our benchmark (you can check compute capability of each NVIDIA GPU &lt;a href=&quot;https://developer.nvidia.com/cuda-gpus#compute&quot;&gt;here&lt;/a&gt;). However, in our tests on A100 the memory efficient attention performed better than flash attention for the particular case of SD, due to the small number of attention heads and small batch size.  PyTorch understands this and chooses memory efficient attention over flash attention for SD when both are available (see the logic &lt;a href=&quot;https://github.com/pytorch/pytorch/blob/d8e795ecd53670682bd3b2e5ff1f378402b147d5/aten/src/ATen/native/transformers/cuda/sdp_utils.h#L33-L71&quot;&gt;here&lt;/a&gt;). For full control over the attention backends (memory-efficient attention, flash attention, “vanilla math”, or any future ones), power users can enable and disable them manually with the help of the context manager &lt;a href=&quot;https://pytorch.org/docs/master/backends.html#torch.backends.cuda.sdp_kernel&quot;&gt;torch.backends.cuda.sdp_kernel&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;compilation&quot;&gt;Compilation&lt;/h3&gt;

&lt;p&gt;Compilation is a &lt;a href=&quot;https://pytorch.org/get-started/pytorch-2.0/#user-experience&quot;&gt;new feature of PyTorch 2.0&lt;/a&gt;, enabling significant speedups with a very simple user experience. To invoke the default behavior, simply wrap a PyTorch module or a function into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;model = torch.compile(model)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PyTorch compiler then turns Python code into a set of instructions which can be executed efficiently without Python overhead. The compilation happens dynamically the first time the code is executed. With the default behavior, under the hood PyTorch utilized &lt;a href=&quot;https://pytorch.org/docs/master/dynamo/index.html&quot;&gt;TorchDynamo&lt;/a&gt; to compile the code and &lt;a href=&quot;https://dev-discuss.pytorch.org/t/torchinductor-a-pytorch-native-compiler-with-define-by-run-ir-and-symbolic-shapes/747&quot;&gt;TorchInductor&lt;/a&gt; to further optimize it. See &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/dynamo_tutorial.html&quot;&gt;this tutorial&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;Although the one-liner above is enough for compilation, certain modifications in the code can squeeze a larger speedup. In particular, one should avoid so-called graph breaks - places in the code which PyTorch can’t compile. As opposed to previous PyTorch compilation approaches (like TorchScript), PyTorch 2 compiler doesn’t break in this case. Instead it falls back on eager execution - so the code runs, but with reduced performance. We introduced a few minor changes to the SD code to eliminate graph breaks (&lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/compare/main...sgrigory:stablediffusion2:optimize-w-compile?expand=1#diff-db5d837c282869a3588a17885e0baec3e29bf0701af6f4f34774d7b94503f7d4R34&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/compare/main...sgrigory:stablediffusion2:optimize-w-compile?expand=1#diff-db5d837c282869a3588a17885e0baec3e29bf0701af6f4f34774d7b94503f7d4R336-R343&quot;&gt;here&lt;/a&gt;). See this &lt;a href=&quot;https://pytorch.org/docs/master/dynamo/faq.html#identifying-the-cause-of-a-graph-break&quot;&gt;doc&lt;/a&gt; to learn more about graph breaks and how to eliminate them.&lt;/p&gt;

&lt;p&gt;Note that compilation &lt;a href=&quot;https://github.com/openai/triton/blob/b5d32896b1f89fc44a82f8df3bb010934c53f4f5/README.md?plain=1#L66-L68&quot;&gt;requires GPU compute capability &amp;gt;= SM 7.0&lt;/a&gt; to run in non-eager mode. This covers all GPUs in our benchmarks -  T4, V100, A10, A100 - except for P100 (see the &lt;a href=&quot;https://developer.nvidia.com/cuda-gpus#compute&quot;&gt;full list&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&quot;other-optimizations&quot;&gt;Other optimizations&lt;/h3&gt;

&lt;p&gt;In addition, we have improved efficiency of some memory operations - e.g. creating a tensor on GPU directly rather than creating it on CPU and later moving to GPU (see &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/compare/main...sgrigory:stablediffusion2:optimize-w-compile?expand=1#diff-7f9fb1cdee2602845e0a4ad2a62dfcf86d4a868490e0ff126e8a1d045106d065R166-R167&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/compare/main...sgrigory:stablediffusion2:optimize-w-compile?expand=1#diff-1cd43c874cb6fb8799d24ba5b9e9c2f8a9e058b976b93a09e409c9d5853884f2R150-R220&quot;&gt;here&lt;/a&gt;). The places where such optimizations were necessary were determined by line-profiling and looking at CPU/GPU traces and &lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;Flame Graphs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;benchmarking-setup-and-results-summary&quot;&gt;Benchmarking setup and results summary&lt;/h2&gt;

&lt;p&gt;We have two versions of SD code to compare: &lt;em&gt;original&lt;/em&gt; and &lt;em&gt;optimized&lt;/em&gt;. On top of this, several optimization features (xFormers, PyTorch memory efficient attention, compilation) can be turned on/off. Overall, as mentioned in the introduction, we will be benchmarking 5 configurations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Original code without xFormers&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Original code with xFormers&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Optimized code with vanilla math attention backend and no compilation&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Optimized code with memory-efficient attention backend and no compilation&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Optimized code with memory-efficient attention backend and compilation&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the &lt;em&gt;original version&lt;/em&gt; we took the SD 2.1 release, and placed it &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/tree/cee9b9f057eeef4b481e138da9dbc4fe8ecb0cba&quot;&gt;here&lt;/a&gt; with minimal modifications necessary for benchmarking. It uses PyTorch 1.12 and a custom implementation of attention.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;optimized version&lt;/em&gt; is the code living &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/tree/0f6d17cb2602302bc0f5c7dee6825e4b49a85518&quot;&gt;here&lt;/a&gt;. It uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.MultiheadAttention&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt; and PyTorch 2.0.0.dev20230111+cu117. It also has a few other minor optimizations in PyTorch-related code.&lt;/p&gt;

&lt;p&gt;Please see the appendix “Benchmarked versions definition” in &lt;a href=&quot;/blog/performance-experiments-stable-diffusion/&quot;&gt;the companion page&lt;/a&gt; for the precise definition of the 5 configurations and prompts triggering each of them.&lt;/p&gt;

&lt;p&gt;The table below shows runtime of each version of the code in seconds, and the percentage improvement compared to the &lt;em&gt;original with xFormers&lt;/em&gt;. The compilation time is excluded.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtimes for batch size 1. In parenthesis - relative improvement with respect to the “Original with xFormers” row&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Configuration&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;P100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;T4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;V100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A100&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original without xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;30.4s (-19.3%)
   &lt;/td&gt;
   &lt;td&gt;29.8s (-77.3%)
   &lt;/td&gt;
   &lt;td&gt;13.0s (-83.9%)
   &lt;/td&gt;
   &lt;td&gt;10.9s (-33.1%)
   &lt;/td&gt;
   &lt;td&gt;8.0s (-19.3%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original with xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;25.5s&lt;/strong&gt; (0.0%)
   &lt;/td&gt;
   &lt;td&gt;16.8s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;7.1s&lt;/strong&gt; (0.0%)
   &lt;/td&gt;
   &lt;td&gt;8.2s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;6.7s (0.0%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with vanilla math attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;27.3s (-7.0%)
   &lt;/td&gt;
   &lt;td&gt;19.9s (-18.7%)
   &lt;/td&gt;
   &lt;td&gt;13.2s (-87.2%)
   &lt;/td&gt;
   &lt;td&gt;7.5s (8.7%)
   &lt;/td&gt;
   &lt;td&gt;5.7s (15.1%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;26.5s (-3.8%)
   &lt;/td&gt;
   &lt;td&gt;16.8s (0.2%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;7.1s&lt;/strong&gt; (-0.8%)
   &lt;/td&gt;
   &lt;td&gt;6.9s (16.0%)
   &lt;/td&gt;
   &lt;td&gt;5.3s (20.6%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention and compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;16.4s &lt;/strong&gt;(2.1%)
   &lt;/td&gt;
   &lt;td&gt;7.2s (-2.3%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;6.6s&lt;/strong&gt; (18.6%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;4.1s&lt;/strong&gt; (38.5%)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Runtimes for batch size 2&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Configuration&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;P100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;T4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;V100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A100&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original without xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;58.0s (-21.6%)
   &lt;/td&gt;
   &lt;td&gt;57.6s (-84.0%)
   &lt;/td&gt;
   &lt;td&gt;24.4s (-95.2%)
   &lt;/td&gt;
   &lt;td&gt;18.6s (-63.0%)
   &lt;/td&gt;
   &lt;td&gt;12.0s (-50.6%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original with xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;47.7s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;31.3s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;12.5s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;11.4s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;8.0s (0.0%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with vanilla math attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;49.3s (-3.5%)
   &lt;/td&gt;
   &lt;td&gt;37.9s (-21.0%)
   &lt;/td&gt;
   &lt;td&gt;17.8s (-42.2%)
   &lt;/td&gt;
   &lt;td&gt;12.7s (-10.7%)
   &lt;/td&gt;
   &lt;td&gt;7.8s (1.8%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;47.5s &lt;/strong&gt;(0.4%)
   &lt;/td&gt;
   &lt;td&gt;31.2s (0.5%)
   &lt;/td&gt;
   &lt;td&gt;12.2s (2.6%)
   &lt;/td&gt;
   &lt;td&gt;11.5s (-0.7%)
   &lt;/td&gt;
   &lt;td&gt;7.0s (12.6%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention and compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;28.0s&lt;/strong&gt; (10.5%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;11.4s&lt;/strong&gt; (9.0%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;10.7s &lt;/strong&gt;(6.4%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;6.4s&lt;/strong&gt; (20.3%)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Runtimes for batch size 4&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Configuration&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;P100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;T4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;V100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A100&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original without xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;117.9s (-20.0%)
   &lt;/td&gt;
   &lt;td&gt;112.4s (-81.8%)
   &lt;/td&gt;
   &lt;td&gt;47.2s (-101.7%)
   &lt;/td&gt;
   &lt;td&gt;35.8s (-71.9%)
   &lt;/td&gt;
   &lt;td&gt;22.8s (-78.9%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Original with xFormers&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;98.3s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;61.8s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;23.4s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;20.8s (0.0%)
   &lt;/td&gt;
   &lt;td&gt;12.7s (0.0%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with vanilla math attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;101.1s (-2.9%)
   &lt;/td&gt;
   &lt;td&gt;73.0s (-18.0%)
   &lt;/td&gt;
   &lt;td&gt;28.3s (-21.0%)
   &lt;/td&gt;
   &lt;td&gt;23.3s (-11.9%)
   &lt;/td&gt;
   &lt;td&gt;14.5s (-13.9%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention, no compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;92.9s &lt;/strong&gt;(5.5%)
   &lt;/td&gt;
   &lt;td&gt;61.1s (1.2%)
   &lt;/td&gt;
   &lt;td&gt;23.9s (-1.9%)
   &lt;/td&gt;
   &lt;td&gt;20.8s (-0.1%)
   &lt;/td&gt;
   &lt;td&gt;12.8s (-0.9%)
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimized with mem. efficient attention and compilation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;53.1s &lt;/strong&gt;(14.2%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;20.9s&lt;/strong&gt; (10.6%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;18.6s&lt;/strong&gt; (10.4%)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;11.2s&lt;/strong&gt; (12.2%)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;To minimize fluctuations and external influence on the performance of the benchmarked code, we ran each version of the code one after another, and then repeated this sequence 10 times: A, B, C, D, E,  A, B, … So the results of a typical run would look like the one in the picture below. For results of all runs please see appendix “Per-run data” in &lt;a href=&quot;/blog/performance-experiments-stable-diffusion/&quot;&gt;the companion page&lt;/a&gt;. Note that one shouldn’t rely on comparison of absolute run times between different graphs, but comparison of run times &lt;em&gt;inside&lt;/em&gt; one graph is pretty reliable, thanks to our benchmarking setup.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/stable-diffusion/original_vs_optimized_a100_n_samples_1_n_iter_2_sd2.png&quot; alt=&quot;Stable Diffusion 2.1 benchmarks&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each run of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txt2img.py&lt;/code&gt; generates several batches, which is regulated by the CLI parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--n_iter&lt;/code&gt;. In the benchmarks we used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n_iter = 2&lt;/code&gt;, but introduced an additional “warm-up” iteration, which doesn’t contribute to the run time. This was necessary for the runs with compilation, because compilation happens the first time the code runs, and so the first iteration is much longer than all subsequent. To make comparison fair, we also introduced this additional “warm-up” iteration to all other runs, which is turned on by CLI option &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--skip_first&lt;/code&gt; provided to the modified &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txt2img.py&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The numbers in the table above are for number of iterations 2 (plus a “warm-up one”), prompt ”A photo”, seed 1, PLMS sampler, and autocast turned on. See &lt;a href=&quot;/blog/performance-experiments-stable-diffusion/&quot;&gt;the companion page&lt;/a&gt; for precise CLI commands in appendix “Benchmarked versions definition” and detailed results of individual runs in appendix “Per-run data”.&lt;/p&gt;

&lt;p&gt;The P100, V100, and A100 benchmarks were done on Meta internal infrastructure. The T4 benchmarks were done in Google Colab Pro (see the &lt;a href=&quot;https://colab.research.google.com/drive/1cSP5HoRZCbjH55MdYiRtxC_Q0obQQ5ZD?authuser=1#scrollTo=0d793Fus6RBY&quot;&gt;Google Colab notebook&lt;/a&gt;). The A10 benchmarks were done on g5.4xlarge AWS instances with 1 GPU.&lt;/p&gt;

&lt;h2 id=&quot;conclusions-and-next-steps&quot;&gt;Conclusions and next steps&lt;/h2&gt;

&lt;p&gt;We have shown that new features of PyTorch 2 - compiler and optimized attention implementation - give performance improvements exceeding or comparable with what previously required installation of an external dependency (xFormers). PyTorch achieved this, in particular, by integrating memory efficient attention from xFormers into its codebase. This is a significant improvement for user experience, given that xFormers, being a state-of-the-art library, in many scenarios requires custom installation process and long builds.&lt;/p&gt;

&lt;p&gt;There are a few natural directions in which this work can be continued:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There are new implementations of SD, including a port to &lt;a href=&quot;https://github.com/huggingface/diffusers&quot;&gt;HuggingFace diffusers library&lt;/a&gt;. It would be interesting to benchmark against them. Note that diffusers also require installing xFormers in order to use memory efficient attention&lt;/li&gt;
  &lt;li&gt;The optimizations we implemented and described here are only benchmarked for text-to-image inference so far. It would be interesting to see how they affect training. PyTorch compilation can be directly applied to training; enabling training with PyTorch optimized attention is on the roadmap&lt;/li&gt;
  &lt;li&gt;We intentionally minimized changes to the original SD code. Further profiling and optimization can probably bring more improvements&lt;/li&gt;
  &lt;li&gt;At the moment compilation is applied only to the U-Net model inside the sampler. Since there is a lot happening outside of U-Net (e.g. operations directly in the sampling loop), it would be beneficial to compile the whole sampler. However, this would require analysis of the compilation process to avoid recompilation at every sampling step&lt;/li&gt;
  &lt;li&gt;Current code only applies compilation within the PLMS sampler, but it should be trivial to extend it to other samplers&lt;/li&gt;
  &lt;li&gt;Besides text-to-image generation, SD 2.1 has other pipelines - image-to-image and inpainting. It would be interesting to measure how their performance improves from PyTorch 2 optimizations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Try some of this in the &lt;a href=&quot;https://colab.research.google.com/drive/1cSP5HoRZCbjH55MdYiRtxC_Q0obQQ5ZD?usp=sharing&quot;&gt;Colab&lt;/a&gt; or on a GPU of your choice. See if you can further increase the performance of SD, and share the results! This is your chance to get a preview of PyTorch 2.0 and experience the features coming in the next release.&lt;/p&gt;

&lt;p&gt;As a note, if you want access to new PyTorch features which come after this post is published, just tweak the PyTorch and TorchVision versions in &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/blob/0f6d17cb2602302bc0f5c7dee6825e4b49a85518/environment.yaml#L14-L15&quot;&gt;environment.yaml&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resources&quot;&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;PyTorch 2.0 overview, which has a lot of information on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;: &lt;a href=&quot;https://pytorch.org/get-started/pytorch-2.0/&quot;&gt;https://pytorch.org/get-started/pytorch-2.0/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Tutorial on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;: &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torch_compile_tutorial.html&quot;&gt;https://pytorch.org/tutorials/intermediate/torch_compile_tutorial.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;General compilation troubleshooting: &lt;a href=&quot;https://pytorch.org/docs/master/dynamo/troubleshooting.html&quot;&gt;https://pytorch.org/docs/master/dynamo/troubleshooting.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Details on graph breaks: &lt;a href=&quot;https://pytorch.org/docs/master/dynamo/faq.html#identifying-the-cause-of-a-graph-break&quot;&gt;https://pytorch.org/docs/master/dynamo/faq.html#identifying-the-cause-of-a-graph-break&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Details on guards: &lt;a href=&quot;https://pytorch.org/docs/master/dynamo/guards-overview.html&quot;&gt;https://pytorch.org/docs/master/dynamo/guards-overview.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Video deep dive on TorchDynamo &lt;a href=&quot;https://www.youtube.com/watch?v=egZB5Uxki0I&quot;&gt;https://www.youtube.com/watch?v=egZB5Uxki0I&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Benchmark of SD1 based on HuggingFace implementation: &lt;a href=&quot;https://lambdalabs.com/blog/inference-benchmark-stable-diffusion&quot;&gt;https://lambdalabs.com/blog/inference-benchmark-stable-diffusion&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Tutorial on optimized attention in PyTorch 1.12: &lt;a href=&quot;https://pytorch.org/tutorials/beginner/bettertransformer_tutorial.html&quot;&gt;https://pytorch.org/tutorials/beginner/bettertransformer_tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;We would like to thank Geeta Chauhan, Natalia Gimelshein, Patrick Labatut, Bert Maher, Mark Saroufim, Michael Voznesensky and Francisco Massa for their valuable advice and early feedback on the text.&lt;/p&gt;

&lt;p&gt;Special thanks to Yudong Tao for creating the first version of Stable Diffusion with PyTorch native attention.&lt;/p&gt;

&lt;p&gt;For more information, &lt;a href=&quot;/blog/performance-experiments-stable-diffusion/&quot;&gt;visit this page with additional resources&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Grigory Sizov, Michael Gschwind, Hamid Shojanazeri, Driss Guessous, Daniel Haziza, Christian Puhrsch</name>
        
        
      </author>

      

      

      
        <summary type="html">TL;DR: PyTorch 2.0 nightly offers out-of-the-box performance improvement for Stable Diffusion 2.1 by using the new torch.compile() compiler and optimized implementations of Multihead Attention integrated with PyTorch 2.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Performance experiments with Stable Diffusion</title>
      <link href="https://pytorch.org/blog/performance-experiments-stable-diffusion/" rel="alternate" type="text/html" title="Performance experiments with Stable Diffusion" />
      <published>2023-01-27T00:00:00-08:00</published>
      <updated>2023-01-27T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/performance-experiments-stable-diffusion</id>
      <content type="html" xml:base="https://pytorch.org/blog/performance-experiments-stable-diffusion/">&lt;p&gt;&lt;em&gt;This is a companion to the main blog &lt;a href=&quot;/blog/accelerated-stable-diffusion-2/&quot;&gt;“Accelerated Stable Diffusion with PyTorch 2”&lt;/a&gt;, containing detailed information on benchmarking setup and results of individual experiments. It is mainly aimed at a hands-on reader who would want to reproduce or develop further the work we described in the main text. Please see the main text for all the context and the summary of results.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;appendix-1-benchmarked-versions-definition&quot;&gt;Appendix 1: benchmarked versions definition&lt;/h2&gt;

&lt;p&gt;Here we define precisely what we mean by “original code” and “optimized code” in the main text.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Original code&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Lives in &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2&quot;&gt;https://github.com/sgrigory/stablediffusion2&lt;/a&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;original-benchmark&lt;/code&gt; branch, specifically in &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/tree/cee9b9f057eeef4b481e138da9dbc4fe8ecb0cba&quot;&gt;this commit&lt;/a&gt;. This is almost the same code as in &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion&quot;&gt;https://github.com/Stability-AI/stablediffusion&lt;/a&gt;, with minimal modifications necessary for benchmarking. In particular, the code is able to turn off xFormers attention when the environment variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;USE_XFORMERS&lt;/code&gt; is set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This code uses PyTorch 1.12 and &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/blob/cee9b9f057eeef4b481e138da9dbc4fe8ecb0cba/ldm/modules/attention.py#L165-L196&quot;&gt;the original custom implementation of attention&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optimized code&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;optimized version&lt;/em&gt; is the code living &lt;a href=&quot;https://github.com/sgrigory/stablediffusion2/tree/0f6d17cb2602302bc0f5c7dee6825e4b49a85518&quot;&gt;here&lt;/a&gt;. It has all the optimizations we mentioned in the main text:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.MultiheadAttention&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt; instead of custom attention implementation&lt;/li&gt;
  &lt;li&gt;Compilation with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Other minor optimizations in PyTorch-related code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first optimization (using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.MultiheadAttention&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt;) schematically boils down to the following pseudocode:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CrossAttention(nn.Module):
    def __init__(self, ...):
        # Create matrices: Q, K, V, out_proj
        ...
    def forward(self, x, context=None, mask=None):
       # Compute out = SoftMax(Q*K/sqrt(d))V
       # Return out_proj(out)
       …
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;gets replaced with&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CrossAttention(nn.Module):
    def __init__(self, ...):
        self.mha = nn.MultiheadAttention(...)
    def forward(self, x, context):
	return self.mha(x, context, context)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;See the full diff &lt;a href=&quot;https://github.com/Stability-AI/stablediffusion/compare/main...sgrigory:stablediffusion2:optimize-w-compile?expand=1#diff-db5d837c282869a3588a17885e0baec3e29bf0701af6f4f34774d7b94503f7d4R145-R188&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also introduced the following CLI flags:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--disable_math, --disable_mem_efficient, --disable_flash&lt;/code&gt; to allow turning specific attention backends off&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--compile&lt;/code&gt; to turn on PyTorch compilation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The optimized version uses PyTorch 2.0.0.dev20230111+cu117&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Flags added to both code versions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In both code versions we have added the following CLI options to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txt2img.py&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--skip_first&lt;/code&gt; to use a “warm-up” iteration before starting to measure time. See the end of section “Benchmarking setup and results summary” in &lt;a href=&quot;/blog/accelerated-stable-diffusion-2/&quot;&gt;the main text&lt;/a&gt; on why this was necessary&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--time_file &amp;lt;FILENAME&amp;gt; &lt;/code&gt;to write runtime in seconds in text format to the specified file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Prompts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now it should already be clear how to run the 5 configurations mentioned in the main text. For completeness we provide the prompts which can be used to run each of them. This assumes you have&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;installed dependencies from the original version into conda environment&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; ldm-original&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;installed dependencies from the optimized version into conda environment &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ldm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;downloaded model weights into&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; /tmp/model.ckpt&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;converted model weights to the new architecture and saved them into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tmp/model_native_mha.ckpt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(see &lt;a href=&quot;https://colab.research.google.com/drive/1cSP5HoRZCbjH55MdYiRtxC_Q0obQQ5ZD?usp=sharing&quot;&gt;Colab&lt;/a&gt; for a bash script which does that)&lt;/p&gt;

&lt;p&gt;Prompts for 5 configurations:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Run optimized with memory-efficient attention and compilation
conda activate ldm
git checkout optmize-w-compile
python scripts/txt2img.py --prompt &quot;A photo&quot; --seed 1 --plms --config configs/stable-diffusion/v2-inference_native_mha.yaml --ckpt /tmp/model_native_mha.ckpt --n_iter 2 --n_samples 1 --compile --skip_first

# Run optimized with memory-efficient attention
conda activate ldm
git checkout optmize-w-compile
python stable-diffusion/scripts/txt2img.py --prompt &quot;A photo&quot; --seed 1 --plms --config stable-diffusion/configs/stable-diffusion/v2-inference_native_mha.yaml --ckpt /tmp/model_native_mha.ckpt --n_iter 2 --n_samples 1 --skip_first

# Run optimized without memory-efficient or flash attention
conda activate ldm
git checkout optmize-w-compile
python stable-diffusion/scripts/txt2img.py --prompt &quot;A photo&quot; --seed 1 --plms --config stable-diffusion/configs/stable-diffusion/v2-inference_native_mha.yaml --ckpt /tmp/model_native_mha.ckpt --n_iter 2 --n_samples 1 --disable_mem_efficient --disable_flash --skip_first 

# Run original code with xFormers
conda activate ldm-original
git checkout original-benchmark
python stable-diffusion-original/scripts/txt2img.py --prompt &quot;A photo&quot; --seed 1 --plms --config stable-diffusion-original/configs/stable-diffusion/v2-inference.yaml --ckpt /tmp/model.ckpt --n_iter 2 --n_samples 1 --skip_first

# Run original code without xFormers
conda activate ldm-original
git checkout original-benchmark
USE_XFORMERS=False python stable-diffusion-original/scripts/txt2img.py --prompt &quot;A photo&quot; --seed 1 --plms --config stable-diffusion-original/configs/stable-diffusion/v2-inference.yaml --ckpt /tmp/model.ckpt --n_iter 2 --n_samples 1 --skip_first
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;appendix-2-per-run-data&quot;&gt;Appendix 2: per-run data&lt;/h2&gt;

&lt;p&gt;Plots with per-run benchmark data can be found &lt;a href=&quot;https://drive.google.com/drive/folders/1NWIGDBAsMakMeByQU0FmMFtyoRsUI0pF?usp=share_link&quot;&gt;here&lt;/a&gt;. Each plot shows all the runs for a particular GPU (P100, V100, T4, A10, A100) and batch size (1, 2, or 4). The bar charts in &lt;a href=&quot;/blog/accelerated-stable-diffusion-2/&quot;&gt;the main text&lt;/a&gt; are obtained from this data by averaging. The file names are self-explanatory, for example “original_vs_optimized_A10_n_samples_2_n_iter_2_sd2.png” contains runs for A10 GPU, batch size 2 and number of iterations 2.&lt;/p&gt;

&lt;h2 id=&quot;appendix-3-accelerated-stable-diffusion-1&quot;&gt;Appendix 3: Accelerated Stable Diffusion 1&lt;/h2&gt;

&lt;p&gt;Before the work on Stable Diffusion 2 described in the main text, we also applied similar optimizations to &lt;a href=&quot;https://github.com/CompVis/stable-diffusion&quot;&gt;Stable Diffusion 1&lt;/a&gt; by CompVis prior to the release of Stable Diffusion 2. The original implementation of SD1 does not integrate with xFormers yet, and so the speedup from just using the PyTorch optimized attention instead of custom implementation is significant. It should be noted that the &lt;a href=&quot;https://github.com/huggingface/diffusers#stable-diffusion-is-fully-compatible-with-diffusers&quot;&gt;HuggingFace Diffusers port of SD1&lt;/a&gt; allows integration with xFormers, so an interesting open question which we didn’t explore would be how the performance of SD1 with PyTorch optimized attention compares to HuggingFace SD1+xFormers.&lt;/p&gt;

&lt;p&gt;We benchmarked two versions of SD1, &lt;em&gt;original and optimized&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As the &lt;em&gt;original&lt;/em&gt; version we took the first SD release, and placed it &lt;a href=&quot;https://github.com/sgrigory/stable-diffusion/tree/original-release&quot;&gt;here&lt;/a&gt; with minimal modifications to simplify benchmarking. It uses PyTorch 1.11 and custom implementation of attention.&lt;/li&gt;
  &lt;li&gt;The &lt;em&gt;optimized&lt;/em&gt; version is the code living &lt;a href=&quot;https://github.com/sgrigory/stable-diffusion/tree/9809711e6921dfae8a4c2934f8c737bd03ad32a1&quot;&gt;here&lt;/a&gt;. It uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nn.MultiheadAttention&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CrossAttention&lt;/code&gt; and PyTorch 2.0.0.dev20221220+cu117.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are the results for different GPU architectures and batch size 2:&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;
&lt;strong&gt;Version&lt;/strong&gt;

   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;T4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;P100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;V100&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;A100 &lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
Original SD1 (runtime in s)

   &lt;/td&gt;
   &lt;td&gt;70.9
   &lt;/td&gt;
   &lt;td&gt;71.5
   &lt;/td&gt;
   &lt;td&gt;20.3
   &lt;/td&gt;
   &lt;td&gt;14.4
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
Optimized SD1 (runtime in s)

   &lt;/td&gt;
   &lt;td&gt;52.7 &lt;strong&gt;(-25.6%)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;57.5 &lt;strong&gt;(-19.5%)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;14.3 &lt;strong&gt;(-29.3%)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;10.4 &lt;strong&gt;(&lt;/strong&gt;-&lt;strong&gt;27.9%)&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Same as for SD2, we used Meta hardware for P100, V100, A100 benchmarks. The T4 benchmark was done in Google Colab &lt;a href=&quot;https://colab.research.google.com/drive/1E83F4o6yePnXTI0vUsQTggiZabLipTCD?usp=sharing&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We didn’t apply compilation to SD1, and so didn’t include a “warm-up” iteration in these benchmarks, as we did for SD2.&lt;/p&gt;

&lt;p&gt;Both applying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to SD1 and benchmarking HuggingFace version of SD1 with PyTorch 2 optimisations would be a great exercise for the reader - try it and let us know if you get interesting results.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Grigory Sizov, Michael Gschwind, Hamid Shojanazeri, Driss Guessous, Daniel Haziza, Christian Puhrsch</name>
        
        
      </author>

      

      

      
        <summary type="html">This is a companion to the main blog “Accelerated Stable Diffusion with PyTorch 2”, containing detailed information on benchmarking setup and results of individual experiments. It is mainly aimed at a hands-on reader who would want to reproduce or develop further the work we described in the main text. Please see the main text for all the context and the summary of results.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PyTorch Trace Analysis for the Masses</title>
      <link href="https://pytorch.org/blog/trace-analysis-for-masses/" rel="alternate" type="text/html" title="PyTorch Trace Analysis for the Masses" />
      <published>2023-01-09T00:00:00-08:00</published>
      <updated>2023-01-09T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/trace-analysis-for-masses</id>
      <content type="html" xml:base="https://pytorch.org/blog/trace-analysis-for-masses/">&lt;p&gt;We are excited to announce the public release of Holistic Trace Analysis (HTA), an open source performance analysis and visualization Python library for PyTorch users. HTA takes as input &lt;a href=&quot;https://github.com/pytorch/kineto&quot;&gt;Kineto traces&lt;/a&gt; collected by the &lt;a href=&quot;https://pytorch.org/blog/introducing-pytorch-profiler-the-new-and-improved-performance-tool/&quot;&gt;PyTorch profiler&lt;/a&gt;, which are complex and challenging to interpret, and up-levels the performance information contained in these traces. It was initially developed internally at Meta to understand and debug performance problems for large-scale distributed training jobs on GPUs. The multidisciplinary team has made a number of enhancements to HTA’s features and scaled them to support state-of-the-art ML workloads.&lt;/p&gt;

&lt;p&gt;ML researchers and systems engineers often struggle to computationally scale up their models because they are not aware of the performance bottlenecks in their workloads. The resources requested for a job (e.g. GPUs, memory) are often misaligned with the resources actually required due to lack of visibility “under the hood”. To achieve the best performance from the hardware stack, it is imperative to understand the resource utilization and bottlenecks for distributed training workloads.&lt;/p&gt;

&lt;p&gt;The initial HTA implementation was specifically targeted at Deep Learning Based Recommendation Models (DLRM). To make the features in HTA generic and applicable to use cases such as analyzing Vision and NLP models, we decided to refactor the HTA codebase and make the library available to the larger community. This new codebase has implemented several important ideas which lead to significant efficiency and performance improvements.&lt;/p&gt;

&lt;p&gt;In this blog, we present several features implemented in the open source version of HTA, which can be used as a Python script as well as interactively in a Jupyter notebook. HTA provides the following features:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Breakdown by Dimensions&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Temporal&lt;/strong&gt;: Breakdown of GPU time in terms of time spent in computation, communication, memory events, and idle time on a single node and across all ranks.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Idle Time&lt;/strong&gt;: Breakdown of GPU idle time into waiting for the host, waiting for another kernel or attributed to an unknown cause.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;: Find kernels with the longest duration on each rank.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Communication Computation Overlap&lt;/strong&gt;: Calculate the percentage of time when communication overlaps computation.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Statistical Analysis&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Kernel Duration Distribution&lt;/strong&gt;: Distribution of average time taken by longest kernels across different ranks.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CUDA Kernel Launch&lt;/strong&gt;: Distributions of GPU kernels with very small duration, large duration, and excessive launch time.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Augmented Counters (Memory bandwidth, Queue length)&lt;/strong&gt;: Augmented trace files which provide insights into memory copy bandwidth and number of outstanding operations on each CUDA stream.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Patterns&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Frequent CUDA Kernels&lt;/strong&gt;: Find the CUDA kernels most frequently launched by any given PyTorch or user defined operator.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Trace Comparison&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;Trace Diff&lt;/strong&gt;: A trace comparison tool to identify and visualize the differences between traces.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTA source code is available to users via &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis&quot;&gt;Github&lt;/a&gt;. Users can request new features or build their own analysis using the core libraries and data structures provided in the codebase in addition to the features mentioned above.&lt;/p&gt;

&lt;h2 id=&quot;gpu-training-performance-debugging-101&quot;&gt;GPU Training Performance Debugging 101&lt;/h2&gt;

&lt;p&gt;To understand the GPU performance in distributed training jobs, we consider how the model operators interact with the GPU devices and how such interactions are reflected in certain measurable metrics.&lt;/p&gt;

&lt;p&gt;At a high level, we can break down the GPU operations in a model execution into three broad categories, henceforth referred to as kernel types:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Computation (COMP)&lt;/strong&gt; - Compute kernels execute compiled routines for matrix multiplication and similar numeric calculations. They are responsible for all of the number-crunching necessary for model execution.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Communication (COMM)&lt;/strong&gt; - Communication kernels are routines which are responsible for exchanging and synchronizing data between different GPU devices in a distributed training job. The NVIDIA Collective Communication Library (NCCL) is a widely used communication library and all its kernels have the prefix “nccl”. Example NCCL kernels include NCCL_AllGather, NCCL_ReduceScatter, NCCL_AllReduce, etc.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memory (MEM)&lt;/strong&gt; - Memory kernels manage the memory allocations/deallocations on the GPU devices and data movement between the memory space on the host and the GPUs. The memory kernels include Memcpy_H2D, Memcpy_D2H, Memcpy_D2D, Memset, etc. Here, H represents the Host and D represents the GPU Device. Thus, H2D, D2H, D2D stands for Host to Device, Device to Host and Device to Device respectively.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Because a modern GPU device like the NVIDIA A100 GPU is a massively parallel device which is capable of running multiple kernels simultaneously, it is possible to overlap the computation, communication, and memory kernels to reduce the model execution time. One common technique to achieve the overlap is to utilize multiple CUDA streams. A CUDA stream is a sequence of operations that execute on a GPU device in the order in which they are issued by the host code. Different CUDA streams can be interleaved and even run concurrently, thus achieving the effect of kernel overlap.&lt;/p&gt;

&lt;p&gt;To help understand the above concepts, Figure 1 provides a timeline of the GPU kernels in a sample distributed training job on 8 GPUs for one iteration. In the figure below, each rank represents one GPU and the kernels on each GPU run on 6 CUDA streams. In the right column of the figure, you can see names of the GPU kernels used. In the middle of the figure, you see the overlap between compute and communicate kernels. This figure is created using the &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/blob/main/examples/plot_timeline.ipynb&quot;&gt;plot_timeline example notebook&lt;/a&gt; available in HTA.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image6.png&quot; alt=&quot;Figure 1. An example of the execution timeline of GPU Kernels across multiple ranks&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 1. An example of the execution timeline of GPU Kernels across multiple ranks&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The performance of multiple GPU training jobs is affected by multiple factors. Among these factors, how does a model execution create and orchestrate the GPU kernels plays a critical role. HTA provides insights on how the model execution interacts with the GPU devices and highlights the opportunities for performance improvement.&lt;/p&gt;

&lt;p&gt;With the features we built in HTA, we aim to provide users insights into “what is happening under the hood in a distributed GPU training?” We briefly describe these features in the next few paragraphs.&lt;/p&gt;

&lt;h2 id=&quot;features-in-holistic-trace-analysis&quot;&gt;Features in Holistic Trace Analysis&lt;/h2&gt;

&lt;p&gt;For most users, understanding the performance of GPU training jobs is nontrivial. Thus, we built this library to simplify the task of trace analysis and provide the user useful insights by examining the model execution traces. As the first step, we developed features which are important and generic enough so that most users can benefit from this library.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Temporal Breakdown&lt;/strong&gt;: We begin by asking whether the GPU is spending time on computation, communication, memory events, or is it idle? To answer this question, the temporal breakdown feature presents a breakdown in terms of these categories. To achieve high training efficiency the code should maximize time used by computation kernels and minimize idle time and non-compute time (time used by communication or memory kernels). This is accomplished by implementing concurrent execution of computation kernels with communication or memory kernels. &lt;em&gt;Note that, during concurrent execution of computation kernels with communication/memory kernels the time spent by communication/memory kernels is accounted for under compute time.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image3.png&quot; alt=&quot;Figure 2: Temporal Breakdown across 8 GPUs&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 2: Temporal Breakdown across 8 GPUs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kernel Breakdown&lt;/strong&gt;: It is natural to ask which kernels are taking the most amount of time. The next feature breaks down the time spent within each kernel type (COMM, COMP, MEM) and sorts them by duration. We present this information for each kernel type and for each rank as a pie chart. See figure 3 below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image1.png&quot; alt=&quot;Figure 3: Pie chart of top computation and communication kernels&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 3: Pie chart of top computation and communication kernels&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kernel Duration Distribution&lt;/strong&gt;: Subsequently, one can also ask - for any given kernel, what is the distribution of the time spent across the ranks? To answer this, HTA generates bar graphs for the average duration of a given kernel across all ranks. Additionally, the error bars in the bar graphs show the minimum and maximum amount of time taken by a given kernel on a given rank. Figure 4 below shows a discrepancy between average duration on rank 0 as compared to other ranks. This anomalous behavior on rank 0 guides the user on where to look for possible bugs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image4.png&quot; alt=&quot;Figure 4: Average duration of NCCL AllReduce Kernel across 8 ranks&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 4: Average duration of NCCL AllReduce Kernel across 8 ranks&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Communication Computation Overlap&lt;/strong&gt;: In distributed training, a significant amount of time is spent in communication and synchronization events among multiple GPU devices. To achieve high GPU efficiency (i.e. TFLOPS/GPU) it is vital to keep the GPU doing actual computation work. In other words, a GPU should not be blocked because of waiting for data from other GPUs. One way to measure the extent to which computation is blocked by data dependencies is to calculate the computation-communication overlap. Higher GPU efficiency is observed if communication events overlap computation events. Lack of communication and computation overlap will lead to the GPU being idle, thus the efficiency would be low. Thus, the communication computation overlap feature calculates the percentage of time communication and computation overlap in a job for each rank and generates a bar graph representation. See figure below. More precisely, we measure the following ratio&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;(time spent in computation while communicating) / (time spent in communication)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image5.png&quot; alt=&quot;Figure 5: Communication computation overlap&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 5: Communication computation overlap&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Augmented Counters (Queue length, Memory bandwidth)&lt;/strong&gt;: To aid in debugging, HTA calculates the memory bandwidth statistics for D2H, H2D and D2D memory copy (memcpy) and memory set (memset) events. Additionally, HTA also computes the number of outstanding CUDA operations on each CUDA stream. We refer to this as queue length. When the queue length on a stream is 1024 or larger new events cannot be scheduled on that stream and the CPU will stall until the GPU events have processed. Additionally, HTA generates a new trace file containing tracks with the memory bandwidth and queue length time series. See Figure 6 below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/trace-image2.png&quot; alt=&quot;Figure 6: Memory Bandwidth and Queue Length&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;em&gt;Figure 6: Memory Bandwidth and Queue Length&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;These primary features give us a peek into the system performance and help answer “what is happening in the system?”. As HTA evolves, we hope to address “why is X happening?” and also suggest possible solutions to overcome the bottlenecks.&lt;/p&gt;

&lt;h2 id=&quot;installation-and-usage&quot;&gt;Installation and Usage&lt;/h2&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;For installing the HTA please refer to the &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/blob/main/README.md&quot;&gt;README&lt;/a&gt;. In brief, the user is required to clone the &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis&quot;&gt;repo&lt;/a&gt; and install the necessary Python packages via pip.&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;This version of Holistic Trace Analysis is currently in beta and we recommend using HTA in a Jupyter notebook. A &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/blob/main/examples/trace_analysis_demo.ipynb&quot;&gt;demo notebook&lt;/a&gt; is provided for your convenience. To get started, import the hta package in a Jupyter notebook, create a TraceAnalysis object and off we go in exactly two lines of code.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hta.trace_analysis&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TraceAnalysis&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;analyzer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TraceAnalysis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;folder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;requirements&quot;&gt;Requirements&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;All trace files for a training or inference job must be stored in a unique folder.&lt;/li&gt;
  &lt;li&gt;Trace files are in json or gzipped json format.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;faq&quot;&gt;FAQ&lt;/h2&gt;

&lt;h4 id=&quot;q-how-can-i-install-hta&quot;&gt;Q. How can I install HTA?&lt;/h4&gt;

&lt;p&gt;Please see the &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/blob/main/README.md&quot;&gt;README&lt;/a&gt; in the root directory of the repository.&lt;/p&gt;

&lt;h4 id=&quot;q-is-there-any-documentation-on-the-features-and-api-in-hta&quot;&gt;Q. Is there any documentation on the features and API in HTA?&lt;/h4&gt;

&lt;p&gt;The documentation and detailed API is available &lt;a href=&quot;https://hta.readthedocs.io/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;q-can-you-implement-feature-x&quot;&gt;Q. Can you implement feature X?&lt;/h4&gt;

&lt;p&gt;Depending on how widely the feature is needed and the level of effort required to implement it we would consider developing the feature. Please open a &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/issues&quot;&gt;Github Issue&lt;/a&gt; and tag it with the feature-request label.&lt;/p&gt;

&lt;h4 id=&quot;q-can-i-modify-the-code&quot;&gt;Q. Can I modify the code?&lt;/h4&gt;

&lt;p&gt;Please do and &lt;a href=&quot;https://github.com/facebookresearch/HolisticTraceAnalysis/pulls&quot;&gt;send a PR&lt;/a&gt; along the way, if you think it would be useful for others.&lt;/p&gt;

&lt;h4 id=&quot;q-how-can-i-collect-traces-in-pytorch&quot;&gt;Q. How can I collect traces in PyTorch?&lt;/h4&gt;

&lt;p&gt;Please refer to this tutorial &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/tensorboard_profiler_tutorial.html#use-profiler-to-record-execution-events&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;q-can-hta-be-used-at-production-scale&quot;&gt;Q. Can HTA be used at production scale?&lt;/h4&gt;

&lt;p&gt;Yes, please see a use case study &lt;a href=&quot;https://pytorch.org/blog/performance-debugging-of-production-pytorch-models-at-meta/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Anupam Bhatnagar, Xizhou Feng,  Brian Coutinho, Yifan Liu, Sung-Han Lin, Louis Feng, and Yuzhen Huang</name>
        
        
      </author>

      

      

      
        <summary type="html">We are excited to announce the public release of Holistic Trace Analysis (HTA), an open source performance analysis and visualization Python library for PyTorch users. HTA takes as input Kineto traces collected by the PyTorch profiler, which are complex and challenging to interpret, and up-levels the performance information contained in these traces. It was initially developed internally at Meta to understand and debug performance problems for large-scale distributed training jobs on GPUs. The multidisciplinary team has made a number of enhancements to HTA’s features and scaled them to support state-of-the-art ML workloads.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Compromised PyTorch-nightly dependency chain between December 25th and December 30th, 2022.</title>
      <link href="https://pytorch.org/blog/compromised-nightly-dependency/" rel="alternate" type="text/html" title="Compromised PyTorch-nightly dependency chain between December 25th and December 30th, 2022." />
      <published>2022-12-31T00:00:00-08:00</published>
      <updated>2022-12-31T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/compromised-nightly-dependency</id>
      <content type="html" xml:base="https://pytorch.org/blog/compromised-nightly-dependency/">&lt;p&gt;If you installed PyTorch-nightly on Linux via pip between December 25, 2022 and December 30, 2022, please uninstall it and torchtriton immediately, and use the latest nightly binaries (newer than Dec 30th 2022).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip3 uninstall &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; torch torchvision torchaudio torchtriton
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip3 cache purge
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PyTorch-nightly Linux packages installed via pip during that time installed a dependency, torchtriton, which was compromised on the Python Package Index (PyPI) code repository and ran a malicious binary. This is what is known as a supply chain attack and directly affects dependencies for packages that are hosted on public package indices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Users of the PyTorch &lt;strong&gt;stable&lt;/strong&gt; packages &lt;strong&gt;are not&lt;/strong&gt; affected by this issue.&lt;/p&gt;

&lt;h2 id=&quot;how-to-check-if-your-python-environment-is-affected&quot;&gt;How to check if your Python environment is affected&lt;/h2&gt;

&lt;p&gt;The following command searches for the malicious binary in the torchtriton package (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHON_SITE_PACKAGES/triton/runtime/triton&lt;/code&gt;) and prints out whether your current Python environment is affected or not.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python3 &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;import pathlib;import importlib.util;s=importlib.util.find_spec('triton'); affected=any(x.name == 'triton' for x in (pathlib.Path(s.submodule_search_locations[0] if s is not None else '/' ) / 'runtime').glob('*'));print('You are {}affected'.format('' if affected else 'not '))&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The malicious binary is executed when the triton package is imported, which requires explicit code to do and is not PyTorch’s default behavior.&lt;/p&gt;

&lt;h2 id=&quot;the-background&quot;&gt;The Background&lt;/h2&gt;

&lt;p&gt;At around 4:40pm GMT on December 30 (Friday), we learned about a malicious dependency package (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torchtriton&lt;/code&gt;) that was uploaded to the Python Package Index (PyPI) code repository with the same package name as the one we ship on the &lt;a href=&quot;https://download.pytorch.org/whl/nightly&quot;&gt;PyTorch nightly package index&lt;/a&gt;. Since the &lt;a href=&quot;https://github.com/pypa/pip/issues/8606&quot;&gt;PyPI index takes precedence&lt;/a&gt;, this malicious package was being installed instead of the version from our official repository. This design enables somebody to register a package by the same name as one that exists in a third party index, and pip will install their version by default.&lt;/p&gt;

&lt;p&gt;This malicious package has the same name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torchtriton&lt;/code&gt; but added in code that uploads sensitive data from the machine.&lt;/p&gt;

&lt;h2 id=&quot;what-we-know&quot;&gt;What we know&lt;/h2&gt;

&lt;p&gt;torchtriton on PyPI contains a malicious triton binary which is installed at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHON_SITE_PACKAGES/triton/runtime/triton&lt;/code&gt;. Its SHA256 hash is listed below.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHA256(triton)= 2385b29489cd9e35f92c072780f903ae2e517ed422eae67246ae50a5cc738a0e&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The binary’s main function does the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Get system information
    &lt;ul&gt;
      &lt;li&gt;nameservers from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/resolv.conf&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;hostname from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostname()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;current username from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getlogin()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;current working directory name from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getcwd()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;environment variables&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Read the following files
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;The first 1,000 files in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/*&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/.gitconfig&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$HOME/.ssh/*&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Upload all of this information, including file contents, via encrypted DNS queries to the domain *.h4ck[.]cfd, using the DNS server wheezy[.]io&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The binary’s file upload functionality is limited to files less than 99,999 bytes in size. It also uploads only the first 1,000 files in $HOME (but all files &amp;lt; 99,999 bytes in the .ssh directory).&lt;/p&gt;

&lt;h2 id=&quot;steps-taken-towards-mitigation&quot;&gt;Steps taken towards mitigation&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;torchtriton has been removed as a dependency for our nightly packages and replaced with pytorch-triton (&lt;a href=&quot;https://github.com/pytorch/pytorch/pull/91539&quot;&gt;pytorch/pytorch#91539&lt;/a&gt;) and a dummy package registered on PyPI (so that this issue doesn’t repeat)&lt;/li&gt;
  &lt;li&gt;All nightly packages that depend on torchtriton have been removed from our package indices at https://download.pytorch.org until further notice&lt;/li&gt;
  &lt;li&gt;We have reached out to the PyPI security team to get proper ownership of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torchtriton&lt;/code&gt; package on PyPI and to delete the malicious version&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>The PyTorch Team</name>
        
        
      </author>

      

      

      
        <summary type="html">If you installed PyTorch-nightly on Linux via pip between December 25, 2022 and December 30, 2022, please uninstall it and torchtriton immediately, and use the latest nightly binaries (newer than Dec 30th 2022).</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Torchserve Performance Tuning, Animated Drawings Case-Study</title>
      <link href="https://pytorch.org/blog/torchserve-performance-tuning/" rel="alternate" type="text/html" title="Torchserve Performance Tuning, Animated Drawings Case-Study" />
      <published>2022-12-28T00:00:00-08:00</published>
      <updated>2022-12-28T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/torchserve-performance-tuning</id>
      <content type="html" xml:base="https://pytorch.org/blog/torchserve-performance-tuning/">&lt;p&gt;In this post we discuss performance tuning of Torchserve for serving your models in production. One of the biggest challenges in the life cycle of a ML project is deploying models in production.  This requires a reliable serving solution along with solutions that address the MLOps needs. A robust serving solution needs to provide support for multi model serving, model versioning, metric logging, monitoring and scaling to serve the peak traffic. In this post, we will have an overview of Torchserve and how to tune its performance for production use-cases. We discuss the &lt;a href=&quot;https://ai.facebook.com/blog/using-ai-to-bring-childrens-drawings-to-life/&quot;&gt;Animated Drawings app&lt;/a&gt; from Meta that can turn your human figure sketches to animations and how it could serve the peak traffic with Torchserve. The Animated Drawing’s workflow is below.&lt;/p&gt;

&lt;p&gt;
&lt;img src=&quot;/assets/images/sketch_animator.png&quot; width=&quot;90%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ai.facebook.com/blog/using-ai-to-bring-childrens-drawings-to-life/&quot;&gt;https://ai.facebook.com/blog/using-ai-to-bring-childrens-drawings-to-life/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Many AI systems and tools are designed to handle realistic images of humans, children’s drawings add a level of complexity and unpredictability as they are often constructed in abstract, fanciful ways. These types of morphological and stylistic variations can confuse even state-of-the-art AI systems that excel at spotting objects in photorealistic images and drawings.
Meta AI researchers are working to overcome this challenge so that AI systems will be better able to recognize drawings of human figures in the wildly varied ways that children create them. This great blog post provides more details about the Animated Drawings and the approach taken.&lt;/p&gt;

&lt;h2 id=&quot;torchserve&quot;&gt;Torchserve&lt;/h2&gt;

&lt;p&gt;
&lt;img src=&quot;/assets/images/Tuning-flow-chart.png&quot; width=&quot;90%&quot; /&gt;
&lt;center&gt;&lt;i&gt;Fig1. Overall flow of Torchserve performance tuning&lt;/i&gt; &lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Once you have trained your model, it needs to be integrated into a larger system to have a full-fledged application, we use the term “model serving” to refer to this integration. Basically model serving is making your trained model available to run inferences and subsequent use of the model.&lt;/p&gt;

&lt;p&gt;Torchserve is the Pytorch preferred solution for serving models in production. It is a performant and scalable tool that wraps your model in a HTTP or HTTPS API. It has a frontend implemented in Java that handles multiple tasks from assigning workers for serving models to handling the connection between client and server. Torchserve has a Python backend that is responsible for handling the inference service.&lt;/p&gt;

&lt;p&gt;Torchserve supports multi model serving and versioning for AB test, dynamic batching, logging and metrics. It exposes four APIs for &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/inference_api.md&quot;&gt;inference&lt;/a&gt;, &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/inference_api.md#explanations-api&quot;&gt;explanations&lt;/a&gt;, &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/management_api.md&quot;&gt;management&lt;/a&gt; and &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics_api.md&quot;&gt;metrics&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/inference_api.md&quot;&gt;Inference&lt;/a&gt; API is listening on port 8080 and accessible through localhost by default, this can be configured in &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/configuration.md&quot;&gt;Torchserve configuration&lt;/a&gt; and enable getting predictions from the model.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/inference_api.md#explanations-api&quot;&gt;Explanation&lt;/a&gt; API uses  Captum under the hood to provide explanations of the model that is being served and listens to the port 8080 as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/management_api.md#management-api&quot;&gt;Management&lt;/a&gt; API allows to register or unregister and describe a model. It also enables users to  scale up or down the number of workers that serve the model.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics_api.md&quot;&gt;Metric&lt;/a&gt; API by default listens to port 8082 and enables us to monitor the model that is being served.&lt;/p&gt;

&lt;p&gt;Torchserve let you scale your model serving and handle the peak traffic by supporting &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/batch_inference_with_ts.md&quot;&gt;batch inference&lt;/a&gt; and multiple  workers that serve your model. Scaling can be done through &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/management_api.md&quot;&gt;management&lt;/a&gt;  API and settings through a &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/configuration.md&quot;&gt;configuration&lt;/a&gt; file. Also, metric API helps you to monitor your model serving through default and customizable metrics.&lt;/p&gt;

&lt;p&gt;Other advanced settings such as the length of the queue for the received requests, maximum wait time for a batch of inputs and many other properties are configurable through a&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/configuration.md&quot;&gt; config file&lt;/a&gt; that can be passed to Torchserve when it is started.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Steps to serve your model with Torchserve&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/getting_started.md#install-torchserve-and-torch-model-archiver&quot;&gt;Install Torchserve, model archiver&lt;/a&gt; and its requirements.&lt;/li&gt;
  &lt;li&gt;Choose a default handler that fits your task (e.g image classification, etc) or author a &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/custom_service.md#custom-handlers&quot;&gt;custom handler&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/serve/tree/master/examples/Huggingface_Transformers#create-model-archive-eager-mode&quot;&gt;Package your model&lt;/a&gt; artifacts (trained model checkpoint and all other necessary files for loading and running your model) and the handler into a “.mar” file using &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/model-archiver/README.md&quot;&gt;Torcharchive&lt;/a&gt; and place it in the model store.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/getting_started.md&quot;&gt;Start serving your model&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/getting_started.md#get-predictions-from-a-model&quot;&gt;Run inference&lt;/a&gt;.
We will discuss model handlers and metrics in more detail here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;model-handlers&quot;&gt;Model handlers&lt;/h2&gt;

&lt;p&gt;Torchserve uses a handler in the backend to load the models, preprocess the received data, run inference and post-process the response. Handler in torchserve is a &lt;strong&gt;python script&lt;/strong&gt; that all the model initialization, preprocessing, inference and post processing logic goes into.&lt;/p&gt;

&lt;p&gt;Torchserve provides an out of the box handler for a number of applications like image classification, segmentation, object detection and text classification. It also supports custom handlers, in case your use case is not supported in default handlers.&lt;/p&gt;

&lt;p&gt;It provides a great flexibility in custom handlers, this potentially make Torchserve as &lt;strong&gt;multi-framework&lt;/strong&gt; serving tool. Custom handlers let you define your custom logic to initialize a model that can be used also to load models from other frameworks such as ONNX.&lt;/p&gt;

&lt;p&gt;Torchserve &lt;strong&gt;handler&lt;/strong&gt; is made of four main &lt;strong&gt;functions&lt;/strong&gt;, &lt;strong&gt;initialize&lt;/strong&gt;, &lt;strong&gt;preprocess&lt;/strong&gt;, &lt;strong&gt;inference&lt;/strong&gt; and &lt;strong&gt;postprocess&lt;/strong&gt; that each return a list. The code snippet below shows an example of a custom handler.&lt;strong&gt;Custom handlers inherit&lt;/strong&gt; from &lt;strong&gt;BaseHandler&lt;/strong&gt; in Torchserve and can &lt;strong&gt;overwrite&lt;/strong&gt; any of the &lt;strong&gt;main&lt;/strong&gt; &lt;strong&gt;functions&lt;/strong&gt;.  Here is an example of the handler used for loading the &lt;a href=&quot;https://github.com/facebookresearch/detectron2&quot;&gt;Detectron2&lt;/a&gt; model for figure detection, this model has been exported to Torchscript and uses model.half() to run the inference with FP16, details are explained in another &lt;a href=&quot;&quot;&gt;section&lt;/a&gt; in this post.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyModelHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manifest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manifest&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_properties&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model_dir&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;serialized_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;manifest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;serializedFile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;model_pt_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialized_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;cuda:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gpu_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gpu_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cpu&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model_pt_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map_location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;preprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;request_body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;input_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BytesIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imdecode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromstring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uint8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;permute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;predictions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predictions&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;postprocess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inference_output&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inference_outputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;responses_json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;'classes'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inference_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pred_classes'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tolist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;'scores'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inference_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'scores'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tolist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;boxes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inference_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pred_boxes'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tolist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dumps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;responses_json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;metrics&quot;&gt;Metrics&lt;/h2&gt;

&lt;p&gt;An essential component in serving models in production is the ability to monitor them. &lt;strong&gt;Torchserve&lt;/strong&gt; &lt;strong&gt;collects&lt;/strong&gt; &lt;strong&gt;system level&lt;/strong&gt; &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics.md&quot;&gt;metrics&lt;/a&gt; regularly and &lt;strong&gt;allows&lt;/strong&gt; adding &lt;strong&gt;custom metrics&lt;/strong&gt; as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics.md#system-metrics&quot;&gt;System level metrics&lt;/a&gt;&lt;/strong&gt; consist of CPU utilization, available and used disk space and memory on the host machine along with number of requests with different response codes (e.g 200-300, 400-500 and above 500). &lt;strong&gt;Custom metrics&lt;/strong&gt; can be &lt;strong&gt;added&lt;/strong&gt; to the metrics as explained &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics.md#custom-metrics-api&quot;&gt;here&lt;/a&gt;. TorchServe logs these two sets of metrics to different log files. Metrics are collected by default at:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;System metrics - log_directory/ts_metrics.log&lt;/li&gt;
  &lt;li&gt;Custom metrics - log directory/model_metrics.log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As mentioned before, Torchserve also exposes &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics_api.md&quot;&gt;metric API&lt;/a&gt;, that by default listens to port 8082 and enables users to query and monitor the collected metrics.  The default metrics endpoint returns Prometheus formatted metrics. You can query metrics using curl requests or point a &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics_api.md#prometheus-server&quot;&gt;Prometheus Server&lt;/a&gt; to the endpoint and use &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/metrics_api.md#grafana&quot;&gt;Grafana&lt;/a&gt; for dashboards.&lt;/p&gt;

&lt;p&gt;While serving a model you can query metrics using curl request as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl http://127.0.0.1:8082/metrics
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In case you are looking into exporting the logged metrics, please refer to this &lt;a href=&quot;https://github.com/google/mtail&quot;&gt;example&lt;/a&gt; that uses mtail to export metrics to Prometheus. Tracking these metrics in a dashboard allows you to monitor performance regressions that may have been sporadic or hard to spot during an offline benchmark run.&lt;/p&gt;

&lt;h2 id=&quot;what-to-consider-for-tuning-performance-of-a-model-in-production&quot;&gt;What to consider for tuning performance of a model in production&lt;/h2&gt;

&lt;p&gt;The workflow suggested in Fig 1, is the general idea on how to approach model deployment in production with Torchserve.&lt;/p&gt;

&lt;p&gt;In many cases serving models in production is &lt;strong&gt;optimized&lt;/strong&gt; &lt;strong&gt;based&lt;/strong&gt; on &lt;strong&gt;throughput&lt;/strong&gt; or &lt;strong&gt;latency&lt;/strong&gt; service level agreement (&lt;strong&gt;SLA)s&lt;/strong&gt;. Usually &lt;strong&gt;real-time&lt;/strong&gt; &lt;strong&gt;applications&lt;/strong&gt; are more concerned about &lt;strong&gt;latency&lt;/strong&gt; whereas &lt;strong&gt;off-line applications&lt;/strong&gt; may care more about higher &lt;strong&gt;throughput&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There are a number of main factors contributing to the performance of a serving model in production. In particular, we are focusing on serving Pytorch models with Torchserve here, however most of these factors generalize to all models from other frameworks as well.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Model optimizations&lt;/strong&gt;: this is a pre-step for deploying models into production. This is a very broad discussion that we will get into in a series of future blogs. This includes techniques like quantization, pruning to decrease the size of the model, using Intermediate representations (IR graphs) such as Torchscript in Pytorch, fusing kernels and many others. Currently &lt;a href=&quot;https://github.com/msaroufim/torchprep&quot;&gt;torchprep&lt;/a&gt; provides many of these techniques as a CLI tool.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Batch inference:&lt;/strong&gt; it refers to feeding multiple inputs into a model, while it is essential during training, it can be very helpful to manage the cost at inference time as well. Hardware accelerators are optimized for parallelism and batching helps to saturate the compute capacity and often leads to higher throughput. The main difference in inference is you can’t wait too long to get a batch filled from clients, something we call dynamic batching&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Number of Workers :&lt;/strong&gt; Torchserve uses workers to serve models. Torchserve workers are Python processes that hold a copy of the model weights for running inference. Too few workers means you’re not benefitting from enough parallelism but too many can cause worker contention and degrade end to end performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Hardware :&lt;/strong&gt; choosing the appropriate hardware based on the model, application and latency, throughput budget. This could be one of the &lt;strong&gt;supported&lt;/strong&gt; hardwares in Torchserve, &lt;strong&gt;CPU, GPU, AWS Inferentia&lt;/strong&gt;. Some hardware configurations are intended for best in class performance and others are better suited for cost effective inference. From our experiments we’ve found that GPUs shine best at larger batch sizes whereas the right CPUs and AWS Inferentia can be far more cost effective for lower batch sizes and low latency.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;best-practices-for-performance-tuning-on-torchserve&quot;&gt;Best Practices for Performance tuning on Torchserve&lt;/h2&gt;

&lt;p&gt;To get the best performance out of your model while serving it with Torchserve, we are sharing some of the best practices here. Torchserve provides a  &lt;a href=&quot;https://github.com/pytorch/serve/tree/c87bfec8916d340de5de5810b14a016049b0e395/benchmarks#benchmarking-with-apache-bench&quot;&gt;benchmark&lt;/a&gt; suite that provides helpful insight to make informed decisions on different choices as detailed below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Optimize your model&lt;/strong&gt; as the first step, Pytorch model optimization &lt;a href=&quot;https://pytorch.org/tutorials/&quot;&gt;tutorials&lt;/a&gt;. &lt;strong&gt;Model optimization&lt;/strong&gt; choices are also closely &lt;strong&gt;tied&lt;/strong&gt; to the &lt;strong&gt;hardware&lt;/strong&gt; of choice. We will discuss it in more detail in another blog post.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Deciding&lt;/strong&gt; the &lt;strong&gt;hardware&lt;/strong&gt; for model deployment can be closely related to the latency and throughput budget and cost per inference. Depending on the size of model and application it can vary, for some models like computer vision models it has been historically not affordable to run in production on CPU.  However, by having optimizations such &lt;a href=&quot;https://github.com/pytorch/serve/blob/c87bfec8916d340de5de5810b14a016049b0e395/examples/intel_extension_for_pytorch/README.md&quot;&gt;IPEX&lt;/a&gt; as recently added to Torchserve this has been much more affordable and cost beneficial and you can learn more in this investigative &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torchserve_with_ipex.html&quot;&gt;case study&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Workers&lt;/strong&gt; in Torchserve are Python processes that provide parallelism, setting the number of workers should be done carefully. By default Torchserve launch number of workers equal to VCPUs or available GPUs on the host, this can add a considerable amount of time to the Torchserve start.&lt;/p&gt;

    &lt;p&gt;Torchserve exposes a &lt;a href=&quot;https://github.com/pytorch/serve/blob/c87bfec8916d340de5de5810b14a016049b0e395/docs/configuration.md#config-model&quot;&gt;config property&lt;/a&gt; to set the number of workers. To provide an &lt;strong&gt;efficient parallelism&lt;/strong&gt; through &lt;strong&gt;multiple workers&lt;/strong&gt; and avoiding them to compete over resources, as a baseline we &lt;strong&gt;recommend&lt;/strong&gt; following setting on CPU and GPU:&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt; : In the handler,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.set_num_threads(1) &lt;/code&gt;then set the number of workers to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num physical cores / 2. &lt;/code&gt;But the the best threading configurations can be achieved by leveraging the Intel CPU launcher script.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;GPU&lt;/strong&gt;: number of available GPUs can be set through&lt;a href=&quot;https://github.com/pytorch/serve/blob/c87bfec8916d340de5de5810b14a016049b0e395/docs/configuration.md#limit-gpu-usage&quot;&gt; number_gpus&lt;/a&gt; in config.properties. Torchserve uses round robin to assign workers to GPUs. We recommend setting the number of workers as follows.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Number of worker = (Number of available GPUs) / (Number of Unique Models). &lt;/code&gt;Note that GPUs that are pre-Ampere do not provide any resource isolation with Multi Instance GPUs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Batch size&lt;/strong&gt; can directly affect the latency and the throughput. To better utilize the compute resources batch size needs to be increased. However, there is a tradeoff between latency and throughput. &lt;strong&gt;Larger batch sizes&lt;/strong&gt; can &lt;strong&gt;increase&lt;/strong&gt; the &lt;strong&gt;throughput but results in a higher latency&lt;/strong&gt; as well.  Batch size can be set in Torchserve in two ways, either through&lt;a href=&quot;https://github.com/pytorch/serve/blob/c87bfec8916d340de5de5810b14a016049b0e395/docs/configuration.md#config-model&quot;&gt; model config&lt;/a&gt; in config.properties or while registering the model using &lt;a href=&quot;https://github.com/pytorch/serve/blob/c87bfec8916d340de5de5810b14a016049b0e395/docs/management_api.md#scale-workers&quot;&gt;Management API&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next section, we are going to use Torchserve benchmark suite to decide the best combination of model optimization,  hardware, workers, and batch size.&lt;/p&gt;

&lt;h2 id=&quot;animated-drawings-performance-tuning&quot;&gt;Animated Drawings Performance Tuning&lt;/h2&gt;

&lt;p&gt;To use the Torchserve benchmark suite, first we need to have an archived file, “.mar” file as discussed above, that contains the model, handler and all other artifacts to load and run inference. Animated Drawings uses Detectron2’s implementation of Mask-RCNN for an object detection model.&lt;/p&gt;

&lt;h3 id=&quot;how-to-run-benchmark-suite&quot;&gt;How to run benchmark suite&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/pytorch/serve/tree/master/benchmarks#auto-benchmarking-with-apache-bench&quot;&gt;Automated benchmark suite&lt;/a&gt; in Torchserve let you benchmark multiple models with different setting including batch size and number of worker and finally generate a report for you. To get started:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/pytorch/serve.git

cd serve/benchmarks

pip install -r requirements-ab.txt

apt-get install apache2-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Model level settings can be configured in a yaml file similar to&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;na&quot;&gt;Model_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;eager_mode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;benchmark_engine&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ab&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.mar&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;file&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;workers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;batch_delay&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10000&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;concurrency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Path&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;input&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;backend_profiling&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;False&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;exec_env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;local&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;processors&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cpu&quot;&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;gpus&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;all&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This yaml file will be referenced in the &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/benchmarks/benchmark_config_template.yaml#L12&quot;&gt;benchmark_config_template&lt;/a&gt;.yaml file that includes other settings for generating reports, this can optionally work with AWS cloud watch for logs as well.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python benchmarks/auto_benchmark.py --input benchmark_config_template.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running the &lt;strong&gt;benchmarks&lt;/strong&gt;, results will be written in “csv” file that can be found in “_ /tmp/benchmark/ab_report.csv_” and full report “/tmp/ts_benchmark/report.md”. It will include items such as Torchserve average latency, model P99 latency, throughput, number of concurrency, number of requests, handler time, and some other metrics. Here we focus on some of the important ones that we track to tune the performance which are, &lt;strong&gt;concurrency&lt;/strong&gt;, &lt;strong&gt;model P99&lt;/strong&gt; latency, &lt;strong&gt;throughput&lt;/strong&gt;. We look at these numbers specifically in &lt;strong&gt;combination&lt;/strong&gt; with &lt;strong&gt;batch size&lt;/strong&gt;, the used &lt;strong&gt;device, number of workers&lt;/strong&gt; and if any &lt;strong&gt;model optimization&lt;/strong&gt; has been done.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;latency SLA&lt;/strong&gt; for this model has been set to &lt;strong&gt;100 ms,&lt;/strong&gt; this is real-time application and as we discussed earlier, latency is more of a concern and &lt;strong&gt;throughput&lt;/strong&gt; ideally should be as high as possible while it does &lt;strong&gt;not violate&lt;/strong&gt; the &lt;strong&gt;latency SLA.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Through searching the space, over different batch sizes (1-32), number of workers (1-16) and devices (CPU,GPU), we have run a set of experiments that summarized the best ones in the table below.&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
   &lt;td&gt;Device 
   &lt;/td&gt;
   &lt;td&gt;Concurrency 
   &lt;/td&gt;
   &lt;td&gt;# Requests
   &lt;/td&gt;
   &lt;td&gt;#workers
   &lt;/td&gt;
   &lt;td&gt;Batch size
   &lt;/td&gt;
   &lt;td&gt;Payload/image
   &lt;/td&gt;
   &lt;td&gt;Optimization 
   &lt;/td&gt;
   &lt;td&gt;Throughput 
   &lt;/td&gt;
   &lt;td&gt;Latency P99
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;CPU
   &lt;/td&gt;
   &lt;td&gt;10
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;N/A
   &lt;/td&gt;
   &lt;td&gt;3.45
   &lt;/td&gt;
   &lt;td&gt;305.3 ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;CPU
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;N/A
   &lt;/td&gt;
   &lt;td&gt;3.45
   &lt;/td&gt;
   &lt;td&gt;291.8 ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;GPU
   &lt;/td&gt;
   &lt;td&gt;10
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;N/A
   &lt;/td&gt;
   &lt;td&gt;41.05
   &lt;/td&gt;
   &lt;td&gt;25.48  ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;GPU
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;N/A
   &lt;/td&gt;
   &lt;td&gt;42.21
   &lt;/td&gt;
   &lt;td&gt;23.6  ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;GPU
   &lt;/td&gt;
   &lt;td&gt;10
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;4
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;N/A
   &lt;/td&gt;
   &lt;td&gt;54.78
   &lt;/td&gt;
   &lt;td&gt;73.62 ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;GPU
   &lt;/td&gt;
   &lt;td&gt;10
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;4
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;model.half()
   &lt;/td&gt;
   &lt;td&gt;78.62
   &lt;/td&gt;
   &lt;td&gt;50.69 ms
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;GPU
   &lt;/td&gt;
   &lt;td&gt;10
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1
   &lt;/td&gt;
   &lt;td&gt;8
   &lt;/td&gt;
   &lt;td&gt;small
   &lt;/td&gt;
   &lt;td&gt;model.half()
   &lt;/td&gt;
   &lt;td&gt;85.29
   &lt;/td&gt;
   &lt;td&gt;94.4 ms
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The latency of this model on CPU with all of the tried settings in terms of batch size, concurrency and number of workers did not meet the SLA, in fact ~13x higher.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Moving&lt;/strong&gt; the model serving &lt;strong&gt;to GPU&lt;/strong&gt;, immediately could &lt;strong&gt;improve&lt;/strong&gt; the &lt;strong&gt;latency&lt;/strong&gt; ~**13x **from 305 ms down to 23.6 ms.&lt;/p&gt;

&lt;p&gt;One of the &lt;strong&gt;simplest&lt;/strong&gt; &lt;strong&gt;optimizations&lt;/strong&gt; that we could do for the model was lowering its precision to &lt;strong&gt;fp16&lt;/strong&gt;, it is one liner (&lt;strong&gt;model.half()&lt;/strong&gt;)  and could reduce the &lt;strong&gt;model P99 latency **by  **32%&lt;/strong&gt; and increase the throughput by almost the same amount.&lt;/p&gt;

&lt;p&gt;There could be other optimization done by Torchscripting the model and using  &lt;a href=&quot;https://github.com/pytorch/pytorch/blob/master/torch/jit/_freeze.py#L168&quot;&gt;optimize_for_inference&lt;/a&gt; or other tricks including onnx or tensorrt runtime optimizations which leverage aggressive fusions are out of the scope of this post. We will discuss model optimizations in a separate post.&lt;/p&gt;

&lt;p&gt;We found both on CPU and GPU , setting **number of workers=1 **worked the best in this case.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Moving the model to GPU, using &lt;strong&gt;number of workers = 1&lt;/strong&gt;, and &lt;strong&gt;batch size = 1&lt;/strong&gt; increased the &lt;strong&gt;Throughput ~12x compared&lt;/strong&gt; to &lt;strong&gt;CPU and latency ~13x.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Moving the model to GPU, using &lt;strong&gt;model.half()&lt;/strong&gt;, &lt;strong&gt;number of workers = 1&lt;/strong&gt;, and &lt;strong&gt;batch size = 8&lt;/strong&gt; yielded &lt;strong&gt;best&lt;/strong&gt; results in terms of &lt;strong&gt;Throughput&lt;/strong&gt; and tolerable latency. &lt;strong&gt;Throughput&lt;/strong&gt; increased &lt;strong&gt;~25x compared&lt;/strong&gt; to &lt;strong&gt;CPU with latency still meeting the SLA (94.4ms).&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note: if you are running the benchmark suite, make sure you are setting a proper &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;batch_delay&lt;/code&gt; and set the concurrency of the request to a number proportional to your batch size. Concurrency here means the number of concurrent requests being sent to the server.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this post, we have discussed the considerations and knobs that Torchserve expose to tune the performance in production. We have discussed the Torchserve benchmark suite as a means to tune the performance and get insights on possible choices for model optimizations, hardware choice and cost in general. We used Animated Drawings app which uses Detectron2’s Mask-RCNN model as a case-study to showcase the performance tuning with benchmark suite.&lt;/p&gt;

&lt;p&gt;For more details on Performance tuning in Torchserve please refer to our documentation &lt;a href=&quot;https://github.com/pytorch/serve/blob/master/docs/performance_guide.md&quot;&gt;here&lt;/a&gt;.
Also feel free to open a ticket on &lt;a href=&quot;https://github.com/pytorch/serve/issues&quot;&gt;Torchserve repo&lt;/a&gt; for any further questions and feedback.&lt;/p&gt;

&lt;h3 id=&quot;acknowledgement&quot;&gt;Acknowledgement&lt;/h3&gt;

&lt;p&gt;We would like to thank Somya Jain (Meta), Christopher Gustave (Meta) for their great support and guidance throughout many steps of this blog and providing insights to Sketch Animator workflow. Also, special thanks to&lt;a href=&quot;https://www.linkedin.com/in/li-ning-7274604/&quot;&gt; Li Ning&lt;/a&gt; from AWS for the great efforts to make performance tuning much easier on Torchserve with automated benchmark suite.&lt;/p&gt;

&lt;style&gt;

    td{
        border: 1px solid black;
    }
    
    /* article.pytorch-article table tr td:first-of-type{
        padding: 0.3125rem;
    }

    article.pytorch-article table td {
    padding: 0.3125rem;
    } */

   li a:focus, li a:hover, li a:active{
    cursor: pointer;
    text-decoration: underline;
    }

    ol a:hover, ol a:active{
    cursor: pointer;
    text-decoration: underline;
    }

}

&lt;/style&gt;</content>

      
      
      
      
      

      <author>
          <name>Hamid Shojanazeri, Geeta Chauhan, Mark Saroufim, Jesse Smith</name>
        
        
      </author>

      

      

      
        <summary type="html">In this post we discuss performance tuning of Torchserve for serving your models in production. One of the biggest challenges in the life cycle of a ML project is deploying models in production. This requires a reliable serving solution along with solutions that address the MLOps needs. A robust serving solution needs to provide support for multi model serving, model versioning, metric logging, monitoring and scaling to serve the peak traffic. In this post, we will have an overview of Torchserve and how to tune its performance for production use-cases. We discuss the Animated Drawings app from Meta that can turn your human figure sketches to animations and how it could serve the peak traffic with Torchserve. The Animated Drawing’s workflow is below.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Scaling Vision Model Training Platforms with PyTorch</title>
      <link href="https://pytorch.org/blog/scaling-vision-model-training-platforms-with-pytorch/" rel="alternate" type="text/html" title="Scaling Vision Model Training Platforms with PyTorch" />
      <published>2022-12-22T00:00:00-08:00</published>
      <updated>2022-12-22T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/scaling-vision-model-training-platforms-with-pytorch</id>
      <content type="html" xml:base="https://pytorch.org/blog/scaling-vision-model-training-platforms-with-pytorch/">&lt;p&gt;&lt;em&gt;TL;DR: We demonstrate the use of PyTorch with FairScale’s FullyShardedDataParallel (FSDP) API in writing large vision transformer models. We discuss our techniques for scaling and optimizing these models on a GPU cluster. The goal of this platform scaling effort is to enable research at scale. This blog does not discuss model accuracy, new model architectures, or new training recipes.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h2&gt;

&lt;p&gt;Latest vision research [1, 2] demonstrates model scaling as a promising research direction. In this project, we aim to enable our platforms to train massive vision transformer (ViT) [3] models. We present our work on scaling the largest trainable ViT from 1B to 120B parameters in FAIR vision platforms. We wrote ViT in PyTorch and leveraged its support for large-scale, distributed training on a GPU cluster.&lt;/p&gt;

&lt;p&gt;In the rest of this blog, we will first discuss the main challenges, namely &lt;em&gt;scalability&lt;/em&gt;, &lt;em&gt;optimization&lt;/em&gt;, and &lt;em&gt;numerical stability&lt;/em&gt;. Then we will discuss how we tackle them with techniques including &lt;em&gt;data and model parallelism&lt;/em&gt;, &lt;em&gt;automatic mixed precision&lt;/em&gt;, &lt;em&gt;kernel fusion&lt;/em&gt;, and &lt;em&gt;bfloat16&lt;/em&gt;. Finally, we present our results and conclude.&lt;/p&gt;

&lt;h2 id=&quot;2-main-challenges&quot;&gt;2. Main Challenges&lt;/h2&gt;

&lt;h3 id=&quot;21-scalability&quot;&gt;2.1 Scalability&lt;/h3&gt;

&lt;p&gt;The key scalability challenge is to efficiently shard a model’s operations and state across multiple GPUs. A 100B parameter model requires ~200GB of RAM just for parameters, assuming fp16 representation. So, it is impossible to fit the model on a single GPU (A100 has at most 80GB RAM). Therefore, we need some way to efficiently shard a model’s data (input, parameters, activations, and optimizer state) across multiple GPUs.&lt;/p&gt;

&lt;p&gt;Another aspect of this problem is to scale without significantly changing the training recipe. E.g. Certain representation learning recipes use a global batch size of up to 4096 beyond which we start to see accuracy degradation. We cannot scale to more than 4096 GPUs without using some form of tensor or pipeline parallelism.&lt;/p&gt;

&lt;h3 id=&quot;22-optimization&quot;&gt;2.2 Optimization&lt;/h3&gt;

&lt;p&gt;The key optimization challenge is to maintain high GPU utilization even as we scale the number of model parameters and flops. When we scale models to teraflops and beyond, we start to hit major bottlenecks in our software stack that super-linearly increase training time and reduce accelerator utilization. We require hundreds or thousands of GPUs to run just a single experiment. Improvements in accelerator utilization can lead to significant reductions in cost and improve fleet utilization. It enables us to fund more projects and run more experiments in parallel.&lt;/p&gt;

&lt;h3 id=&quot;23-numerical-stability&quot;&gt;2.3 Numerical Stability&lt;/h3&gt;

&lt;p&gt;The key stability challenge is to avoid numerical instability and divergence at large scale. We empirically observed in our experiments that the training instability gets severe and hard to deal with when we scale up model sizes, data, batch sizes, learning rate, etc. Vision Transformers particularly face training instability even at a lower parameter threshold. E.g., we find it challenging to train even ViT-H (with just 630M parameters) in mixed-precision mode without using strong data augmentation. We need to study the model properties and training recipes to make sure that the models train stably and converge.&lt;/p&gt;

&lt;h2 id=&quot;3-our-solutions&quot;&gt;3. Our Solutions&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Figure 1&lt;/strong&gt; depicts our solutions to each of the challenges.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-vision-figure_1-solutions-to-the-challenges.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;31-addressing-scaling-challenges-with-data-parallelism-and-model-parallelism&quot;&gt;3.1 Addressing scaling challenges with data parallelism and model parallelism&lt;/h3&gt;

&lt;p&gt;We apply various forms of data and model parallelism to enable fitting very large models in GPU memory.&lt;/p&gt;

&lt;p&gt;We use FairScale’s &lt;em&gt;FullyShardedDataParallel (FSDP)&lt;/em&gt; API [4], based on PyTorch, to shard parameters, gradients, and optimizer state across multiple GPUs, thereby reducing the memory footprint per GPU. This process consists of the following three steps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Step 1: We wrapped the entire model in a single FSDP instance. This shards the model parameters at the end of a forward pass and gathers parameters at the beginning of a forward pass. This enabled us to scale ~3x from 1.5B to 4.5B parameters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step 2: We experimented with wrapping individual model layers in separate FSDP instances. This nested wrapping further reduced the memory footprint by sharding and gathering parameters of individual model layers instead of an entire model. The peak memory is then determined by an individually wrapped transformer block in GPU memory in this mode instead of the entire model.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step 3: We used &lt;em&gt;activation-checkpoint&lt;/em&gt; to reduce the memory consumption by activations. It saves the input tensors and discards the intermediate activation tensors during the forward pass. These are recomputed during the backward pass.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition, we experimented with model-parallelism techniques such as pipeline parallelism [5], which allow us to scale to more GPUs without increasing the batch size.&lt;/p&gt;

&lt;h3 id=&quot;32-addressing-optimization-challenges-with-advanced-amp-and-kernel-fusion&quot;&gt;3.2 Addressing optimization challenges with advanced AMP and kernel fusion&lt;/h3&gt;

&lt;h4 id=&quot;advanced-amp&quot;&gt;Advanced AMP&lt;/h4&gt;

&lt;p&gt;Automatic Mixed Precision (AMP) [6] training refers to training models using a lower precision of bits than FP32 or the default but still maintaining accuracy. We experimented with three levels of AMP as described below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AMP O1: This refers to training in mixed precision where weights are in FP32 and some operations are in FP16. With AMP O1, the ops that might impact accuracy remain in FP32 and are not autocasted to FP16.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AMP O2: This refers to training in mixed precision but with more weights and ops in FP16 than in O1. Weights do not implicitly remain in FP32 and are cast to FP16. A copy of the master weights is maintained in the FP32 precision that is used by the optimizer. If we want the normalization layer weights in FP32 then we need to explicitly use layer wrapping to ensure that.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Full FP16: This refers to training in full FP16 where weights and operations are in FP16. FP16  is challenging to enable for training due to convergence issues.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We found that AMP O2 with LayerNorm wrapping in FP32 leads to the best performance without sacrificing accuracy.&lt;/p&gt;

&lt;h4 id=&quot;kernel-fusion&quot;&gt;Kernel Fusion&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;To reduce GPU kernel launch overhead and increase GPU work granularity, we experimented with kernel fusions, including fused dropout and fused layer-norm, using the &lt;a href=&quot;https://github.com/facebookresearch/xformers&quot;&gt;xformers library&lt;/a&gt; [7].&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33-addressing-stability-challenges-by-studying-ops-numerical-stability-and-training-recipes&quot;&gt;3.3 Addressing stability challenges by studying ops numerical stability and training recipes&lt;/h3&gt;

&lt;h4 id=&quot;bfloat16-in-general-but-with-layernorm-in-fp32&quot;&gt;BFloat16 in general but with LayerNorm in FP32&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&quot;https://cloud.google.com/tpu/docs/bfloat16&quot;&gt;bfloat16&lt;/a&gt; (BF16) [8] floating-point format provides the same dynamic range as FP32 with a memory footprint identical to FP16. We found that we could train models in the BF16 format using the same set of hyperparameters as in FP32, without special parameter tuning. Nevertheless, we found that we need to keep LayerNorm in FP32 mode in order for the training to converge.&lt;/p&gt;

&lt;h3 id=&quot;34-final-training-recipe&quot;&gt;3.4 Final training recipe&lt;/h3&gt;

&lt;p&gt;A summary of the final training recipe.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Wrap the outer model in an FSDP instance. Enable parameter sharding after the forward pass.&lt;/li&gt;
  &lt;li&gt;Wrap individual ViT blocks with activation checkpointing, nested FSDP wrapping, and parameter flattening.&lt;/li&gt;
  &lt;li&gt;Enable mixed precision mode (AMP O2) with bfloat16 representation. Maintain the optimizer state in FP32 precision to enhance numerical stability.&lt;/li&gt;
  &lt;li&gt;Wrap normalization layers like LayerNorm in FP32 for better numerical stability.&lt;/li&gt;
  &lt;li&gt;Maximize the Nvidia TensorCore utilization by keeping matrix dimensions to be multiple of 8. For More details check &lt;a href=&quot;https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9926-tensor-core-performance-the-ultimate-guide.pdf&quot;&gt;Nvidia Tensor Core Performance Guide&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-results&quot;&gt;4. Results&lt;/h2&gt;

&lt;p&gt;In this section, we show the scaling results of ViT on three types of tasks: (1) image classification, (2) object detection (3) video understanding. &lt;strong&gt;Our key result is that we are able to train massive ViT backbones across these vision tasks after applying the discussed scaling and optimization techniques. This enables vision research at a much larger scale.&lt;/strong&gt; We trained the models to convergence to verify that we maintain the current baselines even with all the optimizations. A common trend in Figures 2, 3, 4 is that we are able to train up to 25B-param models with an epoch time of less than 4 hours on 128 A100 GPUs. The 60B and 120B models are relatively slower to train.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 2&lt;/strong&gt; shows the &lt;em&gt;image-classification&lt;/em&gt; scaling result. It plots the epoch time for training ViTs on ImageNet using 128 A100-80GB GPUs with different model sizes.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-vision-figure_2-image-classification-scaling-result.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;Figure 2: Image-classification scaling result.&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 3&lt;/strong&gt; shows the &lt;em&gt;object-detection&lt;/em&gt; scaling result. It plots the epoch time for training &lt;a href=&quot;https://arxiv.org/abs/2203.16527&quot;&gt;ViTDet&lt;/a&gt; [9] with different ViT backbones on COCO using 128 A100-80GB GPUs.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-vision-figure_3-object-detection-scaling-result.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;Figure 3: Object-detection scaling result.&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 4&lt;/strong&gt; shows the &lt;em&gt;video-understanding&lt;/em&gt; scaling result. It plots the epoch time for training &lt;a href=&quot;https://arxiv.org/abs/2112.01526&quot;&gt;MViTv2&lt;/a&gt; [10] models on &lt;a href=&quot;https://www.deepmind.com/open-source/kinetics&quot;&gt;Kinetics 400&lt;/a&gt; [11] using 128 V100 (32 GB) GPUs in FP32.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-vision-figure_4-video-understanding-scaling-result.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;Figure 4: Video-understanding scaling result.&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 5&lt;/strong&gt; shows the optimization result with the ViT-H model in Figure 2 on 8 A100-40GB GPUs.
Three versions are used: (1) the baseline uses PyTorch’s DDP [12] with AMP O1, (2) FSDP + AMP-O2 + other optimizations, and (3) FSDP + FP16 + other optimizations. These optimizations altogether speed up the training by up to 2.2x.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-vision-figure_5-training-speedups-from-various-optimizations.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;b&gt;Figure 5: Training speedups from various optimizations.&lt;/b&gt;
&lt;/p&gt;

&lt;h2 id=&quot;5-concluding-remarks&quot;&gt;5. Concluding Remarks&lt;/h2&gt;

&lt;p&gt;We have demonstrated the use of PyTorch with FairScale’s FullyShardedDataParallel (FSDP) API in writing large vision transformer models. We discuss our techniques for scaling and optimizing these models on a GPU cluster.  We hope that this article can motivate others to develop large-scale ML models with PyTorch and its ecosystem.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://arxiv.org/abs/2111.06377&quot;&gt;Masked Autoencoders Are Scalable Vision Learners&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&quot;https://arxiv.org/abs/2201.08371&quot;&gt;Revisiting Weakly Supervised Pre-Training of Visual Perception Models&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&quot;https://arxiv.org/abs/2010.11929v2&quot;&gt;An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] &lt;a href=&quot;https://fairscale.readthedocs.io/en/stable/api/nn/fsdp.html&quot;&gt;fairscale.nn.FullyShardedDataParallel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[5] &lt;a href=&quot;https://pytorch.org/docs/stable/pipeline.html&quot;&gt;Pipeline parallelism in PyTorch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[6] &lt;a href=&quot;https://pytorch.org/docs/stable/amp.html#module-torch.amp&quot;&gt;Automatic Mixed Precision (AMP) in PyTorch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7] &lt;a href=&quot;https://github.com/facebookresearch/xformers&quot;&gt;xformers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[8] &lt;a href=&quot;https://cloud.google.com/tpu/docs/bfloat16&quot;&gt;The bfloat16 numerical format&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[9] &lt;a href=&quot;https://arxiv.org/abs/2203.16527&quot;&gt;Exploring Plain Vision Transformer Backbones for Object Detection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[10] &lt;a href=&quot;https://arxiv.org/abs/2112.01526&quot;&gt;MViTv2: Improved Multiscale Vision Transformers for Classification and Detection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[11] &lt;a href=&quot;https://www.deepmind.com/open-source/kinetics&quot;&gt;https://www.deepmind.com/open-source/kinetics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[12] &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/ddp_tutorial.html&quot;&gt;Getting Started with Distributed Data Parallel (DDP)&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Vaibhav Aggarwal, Mannat Singh, Anjali Sridhar, Yanghao Li, Shoubhik Debnath, Ronghang Hu, Will Feng, Xinlei Chen, Tingting Markstrum, Diana Liskovich, Anupam Bhatnagar, Chay Ryali, Haoqi Fan, Tete Xiao, Min Xu, Rahul Iyer, Christoph Feichtenhofer, Ross Girshick, Piotr Dollar, Aaron Adcock, Wan-Yen Lo, CK Luk</name>
        
        
      </author>

      

      

      
        <summary type="html">TL;DR: We demonstrate the use of PyTorch with FairScale’s FullyShardedDataParallel (FSDP) API in writing large vision transformer models. We discuss our techniques for scaling and optimizing these models on a GPU cluster. The goal of this platform scaling effort is to enable research at scale. This blog does not discuss model accuracy, new model architectures, or new training recipes.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Efficient Large-Scale Training with Pytorch FSDP and AWS</title>
      <link href="https://pytorch.org/blog/efficient-large-scale-training-with-pytorch/" rel="alternate" type="text/html" title="Efficient Large-Scale Training with Pytorch FSDP and AWS" />
      <published>2022-12-16T00:00:00-08:00</published>
      <updated>2022-12-16T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/efficient-large-scale-training-with-pytorch</id>
      <content type="html" xml:base="https://pytorch.org/blog/efficient-large-scale-training-with-pytorch/">&lt;p&gt;Cutting-edge AI models are becoming extremely large. The cost and overhead of training these models is increasing rapidly, and involves large amounts of engineering and guesswork to find the right training regime. FSDP reduces these costs significantly by enabling you to train much larger models with the same amount of resources. FSDP lowers the memory footprint on your GPUs, and is usable via a lightweight configuration that requires substantially less effort, typically with just a few lines of code.&lt;/p&gt;

&lt;p&gt;The main performance gains in FSDP come from maximizing the overlap between network communication and model computation, and eliminating the memory redundancy inherent in traditional data parallel training (DDP).  PyTorch FSDP can train models approximately 4x larger on the same server resources as DDP and 20x larger if we combine activation checkpointing and activation offloading.&lt;/p&gt;

&lt;p&gt;Since PyTorch 1.12, FSDP is now in beta status, and has added a number of new features that can be tuned to further accelerate your model training.&lt;/p&gt;

&lt;p&gt;In this series of blog posts, we will explain multiple performance optimizations you can run with FSDP to boost your distributed training speed and model sizes within the context of your available server resources.  We use the HuggingFace T5 3B, 11B and DeepVit, in fine-tuning mode, as the running examples throughout the series.&lt;/p&gt;

&lt;p&gt;As a preview of some of the optimizations discussed in this series, we show the before and after performance scaled in Flops below (Note that these results can vary based on your server resources and model architecture).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_1.png&quot; width=&quot;90%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;i&gt; *T5 3B Performance measured on AWS A100 and A10 servers. Original with no optimizations and Tuned with the applied optimization &lt;/i&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_2.png&quot; width=&quot;90%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;i&gt; *T5 11B Performance measured on A100 servers. Original with no optimizations and Tuned with the applied optimization &lt;/i&gt;&lt;/p&gt;

&lt;p&gt;In this first post, we will provide a quick overview of FSDP and how it can make training large- scale AI models more efficient.  We will highlight briefly the multiple performance options available, and dive deeper into the details on these in upcoming posts.  We will then conclude with an overview on how to leverage AWS parallel cluster for large- scale training with FSDP.&lt;/p&gt;

&lt;table style=&quot;border: 1px solid black;&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Optimization &lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;T5 Model &lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Throughput Improvement &lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;Mixed Precision
   &lt;/td&gt;
   &lt;td&gt;3 B
   &lt;/td&gt;
   &lt;td&gt;5x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;11 B
   &lt;/td&gt;
   &lt;td&gt;10x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;Activation Checkpointing (AC)
   &lt;/td&gt;
   &lt;td&gt;3 B
   &lt;/td&gt;
   &lt;td&gt;10x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;11 B
   &lt;/td&gt;
   &lt;td&gt;100x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;Transformer Wrapping Policy
   &lt;/td&gt;
   &lt;td&gt;3 B
   &lt;/td&gt;
   &lt;td&gt;2x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;11 B
   &lt;/td&gt;
   &lt;td&gt;&lt;em&gt;Unable to run the experiment without the Transformer wrapping policy.&lt;/em&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;Full Shard Strategy
   &lt;/td&gt;
   &lt;td&gt;3 B
   &lt;/td&gt;
   &lt;td&gt;1.5x
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;11 B
   &lt;/td&gt;
   &lt;td&gt;&lt;em&gt;Not able to run with Zero2&lt;/em&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Performance optimization gains on T5 models over non-optimized.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In our experiments with the T5 3B model, using the  &lt;a href=&quot;https://www.youtube.com/watch?v=HQeKwCsnH4k&amp;amp;list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&amp;amp;index=2&quot;&gt;transformer wrapping policy&lt;/a&gt; resulted in &amp;gt;2x higher throughput measured in TFLOPS versus the default wrapping policy. &lt;a href=&quot;https://www.youtube.com/watch?v=5B4d0FuxSQc&amp;amp;list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&amp;amp;index=3&quot;&gt;Activation checkpointing&lt;/a&gt; resulted in 10x improvement by reinvesting the freed memory from the checkpoints into larger batch size. &lt;a href=&quot;https://www.youtube.com/watch?v=-caN92JtKqA&amp;amp;list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&amp;amp;index=4&quot;&gt;Mixed precision&lt;/a&gt; with BFloat16 resulted in ~5x improvement versus FP32 and finally the &lt;a href=&quot;https://www.youtube.com/watch?v=a3iW6Cggccw&amp;amp;list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&amp;amp;index=5&quot;&gt;full sharding strategy&lt;/a&gt; versus zero2 (DDP)  resulted in 1.5x improvement.&lt;/p&gt;

&lt;p&gt;We ran similar experiments for a larger model, T5 11B, but the larger model size resulted in some changes to the experiment space.  Specifically, we found that two optimizations,  transformer wrapping policy and activation checkpointing, were needed to enable us to run these experiments on 3 nodes (each node had 8 A100 gpus with 80 GB of memory). With these optimizations, we could fit a batch size of 50 and get higher throughput compared to removing each one of them. Thus rather than running on/off solely for a single optimization test as with the 3B model, the larger model experiments were done with 1 of 3 optimizations turned on/off while always running the other two in order to allow a usable batch size for both test states for each item.&lt;/p&gt;

&lt;p&gt;Based on TFLOP comparisons, with the 11B model, we saw even more payoff from the optimizations.  Mixed precision(~10x improvement) and activation checkpointing (~100x improvement) had a much larger impact with the 11B model compared to the 3B parameter model. With mixed precision we could fit ~2x larger batch sizes and with activation checkpointing &amp;gt;15x batch sizes (from 3 with no activation checkpointing to 50 with activation checkpointing) which translated into large throughput improvements.&lt;/p&gt;

&lt;p&gt;We also have observed that for these larger models &amp;gt; 3B, using Zero2 sharding strategy would result in minimal room left in memory for the batch data, and had to go with very small batch sizes (e.g 1-2) that essentially makes full sharding strategy a necessity to enable fitting larger batches sizes.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note - this tutorial assumes a basic understanding of FSDP. To learn more about basics of FSDP please refer to the &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/FSDP_tutorial.html&quot;&gt;getting started&lt;/a&gt; and &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/FSDP_adavnced_tutorial.html&quot;&gt;advanced FSDP &lt;/a&gt;tutorials.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is FSDP? How does it make Large-Scale Training More Efficient&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FSDP&lt;/strong&gt; expands upon distributed data parallel, by parallelizing not just data, but the model parameters, the optimizer states and gradients associated with the model. Specifically - &lt;strong&gt;each&lt;/strong&gt; &lt;strong&gt;GPU only stores a subset of the entire model&lt;/strong&gt; &lt;strong&gt;and the associated subset of optimizer states and gradients.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;To show the evolution of distributed training, we can start from the beginning, where AI models were simply trained on a single GPU.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;DDP (Distributed Data Parallel) was the initial step up from training with only a single GPU, and was an effort to address the data and model size growth, where multiple GPUs each housed their own copy of the same model. The gain here is that the data for each batch could be split and processed independently on each GPU, all at the same time,thus parallelizing the processing of the data set and increasing training speed by the increasing number of GPUs. The tradeoff is the need to communicate the gradients between each GPU to synchronize the models after the backward pass.&lt;/p&gt;

&lt;p&gt;FSDP expands on scaling models by removing the redundancy of optimizer calculations and state storage, as well as gradient and memory storage of model parameters that are present in DDP (DDP = Distributed Data Parallel). This redundancy reduction, along with increased communication overlap where model parameter communication takes place at the same time as model computation, is what allows FSDP to train much larger models with the same resources as DDP.&lt;/p&gt;

&lt;p&gt;A key point is that this efficiency also allows for AI models that are larger than a single GPU to be trained. The model size available for training is now increased to the aggregate memory of all GPUs, rather than the size of a single GPU. (And as a point of note, FSDP can go beyond aggregated GPU memory by leveraging CPU memory as well, though we will not directly cover this aspect here).&lt;/p&gt;

&lt;p&gt;As discussed in a previous &lt;a href=&quot;https://medium.com/pytorch/pytorch-data-parallel-best-practices-on-google-cloud-6c8da2be180d&quot;&gt;blog post&lt;/a&gt;, with DDP the largest model that we could train on 32, A100 gpus with 40 GB memory (4 nodes) was up to 3B parameters, and batch size of 128, with the help of activation checkpointing. By contrast, using FSDP we were able to train up to 81B model size, combining activation checkpointing, along with activation and parameter offloading. In another &lt;a href=&quot;https://medium.com/pytorch/training-a-1-trillion-parameter-model-with-pytorch-fully-sharded-data-parallel-on-aws-3ac13aa96cff&quot;&gt;experiment&lt;/a&gt;, we benchmarked a 1T parameter model with FSDP using 512 gpus.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_3.png&quot; width=&quot;90%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;For intuition on the parameter level workings of FSDP, below we show an animation detailing how the model parameters are sharded and communicated assuming a two GPU scenario and a simple 8 parameter model:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_5.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Above - the animations walk through the steps involved with the initial sharding of the model amongst ranks, and we start the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_gathers&lt;/code&gt; and forward pass&lt;/em&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_6.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We continue through the model with the forward pass. After each FSDP unit completes, non-locally owned params are dropped to free memory, and optionally activations can be checkpointed. This continues until we finish the forward pass and compute the loss.&lt;/em&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_6.5.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;During the backward pass, another &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_gather&lt;/code&gt; is used to load the parameters and the gradients are computed. These gradients are then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reduce_scattered&lt;/code&gt; so that the local owners of each param can aggregate and prepare to update the weights.&lt;/em&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_7.gif&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Finally, each rank passes the summed gradients through the optimizer states and updates the weights to complete the mini-batch.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With the model now distributed across the entire set of available GPUs, the logical question is how data moves through the model given this sharding of model parameters.&lt;/p&gt;

&lt;p&gt;This is accomplished by FSDP coordinating with all GPUs to effectively share (communicate) the respective parts of the model.  The model is decomposed into FSDP units and parameters within each unit are flattened and then sharded across all GPUs.  Within each FSDP unit, GPU’s are assigned interleaving ownership of individual model parameters.&lt;/p&gt;

&lt;p&gt;By interleaving, we mean the following - assuming 2 gpus with an id of 1 and 2, the FSDP unit ownership pattern would be [12121212],  rather than a contiguous chunk of [111222].&lt;/p&gt;

&lt;p&gt;During training, an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_gather&lt;/code&gt; is initiated and the locally owned model parameters within a FSDP unit are shared by the owner GPU with the other non-owners, when they need it, on a ‘just in time’ type basis. FSDP prefetches parameters to overlap &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_gather&lt;/code&gt; communication with computation.&lt;/p&gt;

&lt;p&gt;When those requested parameters arrive, the GPU uses the delivered parameters, in combination with the parameters it already owns, to create a fully populated FSDP unit. Thus there is a moment where each GPU hits peak memory usage while holding a fully populated FSDP unit.&lt;/p&gt;

&lt;p&gt;It then processes the data through the FSDP unit, and drops the parameters it received from other GPU’s to free up memory for the next unit…the process continues over and over proceeding through the entire model to complete the forward pass.The process is then repeated (in general) for the backward pass.(note - this is a simplified version for understanding..there is additional complexity but this should help construct a basic mental model of the FSDP process).&lt;/p&gt;

&lt;p&gt;This eliminates much of the memory redundancy present in DDP, but imposes the cost of higher amounts of network communication to shuttle these requested parameters back and forth amongst all the GPUs.&lt;strong&gt;Overlapping the communication timing with the computation taking place is the basis of many of the performance improvements we’ll discuss in this series.&lt;/strong&gt; The key gains are frequently based on the fact that communication can often take place at the same time as computation.As you can surmise, &lt;strong&gt;having high communication speed is vital for FSDP performance.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;how-do-i-optimize-my-training-with-fsdp&quot;&gt;&lt;strong&gt;How do I optimize my training with FSDP?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;There are four main performance improvements we will cover - the transformer wrapper, activation checkpointing, mixed precision, and selecting the proper sharding strategy. The flowchart below will help as a checklist for tuning options that we will discuss in this post.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_8.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wrapping policy - &lt;em&gt;for transformers, use Transformer wrapping policy&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first performance optimization is leveraging the FSDP transformer wrapper for transformer models.&lt;/p&gt;

&lt;p&gt;One of the pre-defined wrapping policy is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_based_autowrap_policy&lt;/code&gt;. With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size_based_autowrap_policy&lt;/code&gt;, FSDP will traverse the module structure from bottom to top, a new FSDP unit will be created once the current unit has at least the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min_num_params&lt;/code&gt; specified within the size policy (this defaults to 1e8, or 100M). If the module can not be created as an FSDP unit, FSDP will continue to check its parent module. This size based wrapping policy may not be ideal for some model structures, PyTorch distributed team is actively working on a new default wrapping policy in the next release which is based on size and also module execution order, users can simply tune the size and achieve the optimized performance.&lt;/p&gt;

&lt;p&gt;In the current release, you can greatly improve your performance when running Transformer models by using the ‘transformer wrapper’. You will need to provide the appropriate layer class for your model. Here, layer class is the class that houses the Multi-Head Attention and Feed Forward Network.&lt;/p&gt;

&lt;p&gt;FSDP will then form the FSDP units around the layer class rather than arbitrary breaks based on parameter size. By sharding the model around layer classes that are uniformly repeated within the transformer, FSDP can create uniform FSDP units that better balance the overlap of computation and communication. By contrast, size based wrapping can produce very uneven or skewed shards for models, which then have uneven matching of compute vs communication overlap. As discussed earlier, the main driver of FSDP high performance is the overlap of communication and computation, and hence why the Transformer wrapper provides improved performance. Note that the Transformer wrapper can also be used for non-transformer models if these models have a list of uniform layers.&lt;/p&gt;

&lt;p&gt;Let’s compare the performance difference on a T5, 3B parameter model when running under the default wrapper and the transformer wrapper.&lt;/p&gt;

&lt;p&gt;For default wrapping, we don’t need to take any action - we simply pass the model to FSDP as shown:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FSDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;device_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this case FSDP will simply wrap the whole model in a single FSDP unit.&lt;/p&gt;

&lt;p&gt;Running on an &lt;a href=&quot;https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf&quot;&gt;NVIDIA A100-SXM4–40GB&lt;/a&gt; with 8 GPUs, we are able to reach 2.3 TFlops and 95% GPU memory utilization with a batch size of 14.&lt;/p&gt;

&lt;p&gt;However, since T5 is a transformer model, we are better served to leverage the transformer wrapper for this model.&lt;/p&gt;

&lt;p&gt;To use that, we need to isolate the layer class for the transformer, and then pass it in to create our transformer wrapper.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;transformers.models.t5.modeling_t5&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T5Block&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And now we can create our Transformer wrapper:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;transformer_auto_wrapper_policy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transformer_auto_wrap_policy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transformer_layer_cls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;T5Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# &amp;lt; ---- Your Transformer layer class
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With our model aware wrapper ready, we can initialize FSDP:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# invoke FSDP with your transformer wrapper policy:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FSDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;auto_wrap_policy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer_auto_wrapper_policy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;device_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# streaming init
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running this wrapped model, we can see some substantial performance gains.We can fit nearly double the batch size, going to 28, and with better memory and communication efficiency, we see a TFlops increase to 5.07 from 2.3.&lt;/p&gt;

&lt;p&gt;Thus, we’ve increased our training throughput by over 200% (2.19x) due to providing greater model info to FSDP! The transformer wrapping policy results in more fine-grained and balanced FSDP units each holding a layer class, which leads to a more effective communication-computation overlap.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_9.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Above: Graphical comparison of TFlops based on wrapper type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you are training a Transformer model, it pays to configure your training with FSDP using the transformer wrapper. For more information on how to isolate your layer class, please see our in depth video on Transformer wrapping &lt;a href=&quot;https://www.youtube.com/watch?v=HQeKwCsnH4k&quot;&gt;here&lt;/a&gt;, where we walk through a number of transformers showing where the layer class can be found.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mixed precision - &lt;em&gt;use BF16 if you have an Ampere architecture GPU&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FSDP supports a flexible mixed precision policy that gives you granular control over parameters, gradients and buffer data types. This lets you easily leverage BFloat16 or FP16 to increase your training speed by up to 70%.&lt;/p&gt;

&lt;p&gt;*Note that BFloat 16 is only available on Ampere type GPUs. On AWS this is available with p4dn and g5 instances.&lt;/p&gt;

&lt;p&gt;By way of comparison, we can show a 77% speed improvement when comparing fully tuned BFloat16 vs FP32 on an 8B DeepVit model.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_10.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;We have obtained even greater acceleration using BFloat16 in fine-tuning a 3B HuggingFace T5 model as shown in the figures below. We observed that because of the lower precision the validation loss of BFloat16 is slightly behind in the first few epochs, but it is able to catch up and results in the same final accuracy as FP32.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_10a.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;To use mixed precision, we create a policy with our desired data types, and pass it in during the FSDP initialization.&lt;/p&gt;

&lt;p&gt;To create our policy, we need to import the MixedPrecision class, and then define our custom policy using our customized class:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch.distributed.fsdp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MixedPrecision&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bfSixteen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MixedPrecision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;param_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bfloat16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;# Gradient communication precision.
&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;reduce_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bfloat16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;# Buffer precision.
&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;buffer_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bfloat16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FSDP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;auto_wrap_policy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformer_auto_wrapper_policy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;mixed_precision&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bfloatPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can mix and match the precision for parameters, gradients and buffers as you prefer:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;comboPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MixedPrecision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Param precision
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;param_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bfloat16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Gradient communication precision.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;reduce_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Buffer precision.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;buffer_dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For training with FP16, you will need to also use the ShardedGradScaler, which we will cover in subsequent posts. For BFloat16, it is a drop-in replacement.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AnyPrecision Optimizer - &lt;em&gt;going beyond mixed precision with full BF16 training&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mixed precision training, both in FSDP and elsewhere, maintains the working weights in the reduced datatype (BF16 or FP16) while keeping the master weights in full FP32. The reason for the master weights in FP32 is that running in pure BF16 will result in ‘weight stagnation’, where very small weight updates are lost due to the lower precision, and the accuracy flatlines over time while FP32 weights can continue to improve from these small updates.&lt;/p&gt;

&lt;p&gt;In order to resolve this dilemma, we can use the new AnyPrecision optimizer available in &lt;a href=&quot;https://github.com/pytorch/torchdistx&quot;&gt;TorchDistX&lt;/a&gt; (Torch Distributed Experimental) that allows you to successfully train and keep the master weights in pure BF16 instead of FP32. In addition, unlike the typical storage of optimizer states in FP32, AnyPrecision is able to maintain states in pure BF16 as well.&lt;/p&gt;

&lt;p&gt;AnyPrecision enables pure BF16 training by maintaining an extra buffer that tracks the precision lost during the weight updates and re-applies that during the next update…effectively resolving the weight stagnation issue without requiring FP32.&lt;/p&gt;

&lt;p&gt;As a comparison of the throughput gains available with pure BF16 training using AnyPrecision, we ran experiments using FSDP with the T5 11B model with regular FP32 training, Mixed Precision training with BF16, and pure BF16 training using the AnyPrecision optimizer on 3 nodes with A100 gpus as mentioned previously.&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_11.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;As shown above, training with AnyPrecision and pure BF16 resulted in 2x the throughput vs Mixed Precision, and over 20x improvement vs FP32.&lt;/p&gt;

&lt;p&gt;The potential tradeoff is the impact on final accuracy - in the cases we tested, the accuracy was equal or better than FP32 due to a regularization effect from the slightly reduced precision, but your results may vary.&lt;/p&gt;

&lt;p&gt;AnyPrecision optimizer is available for you to test with &lt;a href=&quot;https://github.com/pytorch/torchdistx&quot;&gt;here&lt;/a&gt;, and is a drop in replacement for AdamW optimizer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Activation checkpointing - &lt;em&gt;increasing throughput by trading compute for memory&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_12.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FSDP supports activation checkpointing once the model has been sharded&lt;/strong&gt;, and makes it easy to implement. The graph above shows ~4x throughput improvement using activation checkpointing.&lt;/p&gt;

&lt;p&gt;Activation checkpointing is where the intermediate activations are freed during the forward pass, and a checkpoint is left as a placeholder. This generally increases available GPU memory by over 30%.&lt;/p&gt;

&lt;p&gt;The tradeoff is that during the backward pass, these previously removed intermediate activations must be re-calculated again using information in the checkpoint (duplicate compute), but by leveraging the increased GPU memory, one can increase the batch size such that the net throughput can increase substantially.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# verify we have FSDP activation support ready by importing:
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch.distributed.algorithms._checkpoint.checkpoint_wrapper&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;checkpoint_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;CheckpointImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;apply_activation_checkpointing_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The steps required to implement activation checkpointing is to first import the FSDP checkpointing functions. We need declare our checkpointer wrapper type which is non-reentrant and create a check function to identify which layer to wrap as follows&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;non_reentrant_wrapper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkpoint_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offload_to_cpu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;checkpoint_impl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CheckpointImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NO_REENTRANT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;check_fn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;submodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T5Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;apply_activation_checkpointing_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checkpoint_wrapper_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_reentrant_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check_fn&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Important note - this must be run after the model has been initialized with FSDP.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However, hopefully you’ve seen how some initial tuning with FSDP options can have a large impact on your training performance.&lt;/p&gt;

&lt;p&gt;With that, we turn our attention from how to scale within FSDP, to how to scale your server hardware for FSDP using AWS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Large Scale Training with FSDP on AWS - &lt;em&gt;For multi-node prioritize high speed network&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AWS provides several services that can be used to run distributed training with FSDP: &lt;a href=&quot;https://aws.amazon.com/ec2/instance-types/#Accelerated_Computing&quot;&gt;Amazon EC2 Accelerated Computing instances&lt;/a&gt;, AWS &lt;a href=&quot;https://aws.amazon.com/hpc/parallelcluster/&quot;&gt;ParallelCluster&lt;/a&gt;, and Amazon &lt;a href=&quot;https://aws.amazon.com/sagemaker/features/?nc=sn&amp;amp;loc=2&quot;&gt;Sagemaker&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this series of blog posts, we used &lt;a href=&quot;https://aws.amazon.com/ec2/instance-types/p4/&quot;&gt;Amazon EC2 p4d&lt;/a&gt; instances in a single-instance multi-GPU configuration and in a multi-instance configuration using AWS &lt;a href=&quot;https://aws.amazon.com/hpc/parallelcluster/&quot;&gt;ParallelCluster&lt;/a&gt; and SageMaker in order to run our training jobs.&lt;/p&gt;

&lt;p&gt;Here, we’ll focus specifically on AWS parallel cluster and provide an overview of how to utilize it for training purposes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AWS ParallelCluster Setup&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AWS ParallelCluster is an open source, cluster management tool that makes it easy for you to deploy and manage High Performance Computing (HPC) clusters on AWS.  AWS ParallelCluster uses yaml configuration files to provision all the necessary resources. It also supports multiple instance types, job submission queues, shared file systems like &lt;a href=&quot;https://aws.amazon.com/efs/?trk=3c5ce89c-8865-47a3-bec3-f6820351aa6d&amp;amp;sc_channel=ps&amp;amp;sc_campaign=acquisition&amp;amp;sc_medium=ACQ-P|PS-GO|Non-Brand|Desktop|SU|Storage|Solution|US|EN|DSA&amp;amp;ef_id=Cj0KCQjwuaiXBhCCARIsAKZLt3l6dtldpE152xuxTMa3mbUbaqtTXwsBdfDRIzCL8cw3NO5DO_y1vOgaAj1pEALw_wcB:G:s&amp;amp;s_kwcid=AL!4422!3!579408162404!!!g!!&quot;&gt;Amazon EFS&lt;/a&gt; (NFS) or &lt;a href=&quot;https://aws.amazon.com/fsx/lustre/?refid=3c5ce89c-8865-47a3-bec3-f6820351aa6d&quot; target=&quot;_blank&quot;&gt;Amazon FSx for Lustre&lt;/a&gt;, and job schedulers like AWS Batch and Slurm.&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;/assets/images/largeblog_index_13.png&quot; width=&quot;70%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Workflow on Clusters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The high level idea is to have a cluster that has a head node which controls the compute nodes. The actual training job runs on the compute nodes. Overall steps to run a training job on a cluster are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Set up an AWS ParallelCuster (we discuss below)&lt;/li&gt;
  &lt;li&gt;Connect to the head node, and import the training code/ setup the environment.&lt;/li&gt;
  &lt;li&gt;Pull the data and place it in a shared folder that compute nodes can access (FSx Lustre drive).&lt;/li&gt;
  &lt;li&gt;Run the training job using a job scheduler (in this case Slurm).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Setup AWS ParallelCuster&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To setup AWS ParallelCluster,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Deploy a network stack.&lt;/strong&gt; This step is optional since you could use your account default VPC and let AWS ParallelCluster create your subnets and security groups. However, we prefer to compartmentalize our desired network infrastructure and do this deployment via a CloudFormation stack.&lt;/p&gt;

    &lt;p&gt;Since we deploy a public and a private subnet, we want to create them into an Availability Zone that contains our target instances, in this case p4d. We consult their availability in the region we use (us-east-1) through the following AWS CLI command:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws ec2 describe-instance-type-offerings --location-type availability-zone \ --filters Name=instance-type,Values=p4d.24xlarge --region us-east-1 --output table&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;We see three availability zones containing p4d instances, we pick one of them (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;us-east-1c&lt;/code&gt;, yours may be different) when deploying our network stack. This can be done with the AWS Console or the AWS CLI. In our case we use the latter as follows&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws cloudformation create-stack --stack-name VPC-Large-Scale --capabilities CAPABILITY_IAM --template-body file://VPC-Large-Scale.yaml --parameters ParameterKey=SubnetsAZ,ParameterValue=us-east-1c&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;CloudFormation will deploy our new VPC, subnets, security groups and endpoints on our behalf. Once done, you can retrieve the IDs of the public and private subnets by querying the stack outputs and the values &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PublicSubnet&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PrivateSubnet&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;For example, using the AWS CLI for the private subnet:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws cloudformation describe-stacks --stack-name VPC-Large-Scale --query &quot;Stacks[0].Outputs[?OutputKey=='PrivateSubnet'].OutputValue&quot; --output text&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Create ParallelCluster,&lt;/strong&gt; The cluster configuration file specifies the resources for our cluster. These resources include instance type for Head node, compute nodes, access to S3 buckets, shared storage where our data will be located. We will use Amazon FSx for Lustre that offers a fully managed shared storage service with &lt;a href=&quot;https://en.wikipedia.org/wiki/Lustre_(file_system)&quot;&gt;Lustre&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/lessw2020/t5_11/blob/main/hpc-cluster/cluster.yaml&quot;&gt;Here&lt;/a&gt; is an example of a cluster configuration file. We can use AWs ParallelCluster CLI to create the cluster. Please note that the private and public subnet IDs will need to be replaced by the ones you retrieved earlier. You will be able to control the cluster using the AWS ParallelCluster CLI to start, stop, pause, etc.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pcluster create-cluster --cluster-name my-hpc-cluster --cluster-configuration cluster.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SSH to Head node -&lt;/strong&gt; once the cluster is ready, we can connect to the Head node using the SSH protocol, pull our training code with and place the data in the shared storage specified in the cluster configuration file.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pcluster ssh --cluster-name cluster -i your-key_pair
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Launch the training job -&lt;/strong&gt; now that we have the data and training code, we can launch the slurm job for training. Here is an &lt;a href=&quot;https://github.com/lessw2020/t5_11/blob/main/hpc-cluster/modified-bert.slurm&quot;&gt;example&lt;/a&gt; of a slurm script to launch the job using torchrun.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;More details on how to set up the cluster is out of the scope of this post, however we will have a separate post on it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What’s next?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With this post we provided a high level overview of FSDP and how it efficiently scales distributed AI training. The flowchart included will help provide a checklist for you to review tuning options discussed such as the transformer wrapper and activation checkpointing.&lt;/p&gt;

&lt;p&gt;In the next posts, we will continue with the T5 model and go deeper into each of the topics above, specifically with sharding strategy and other optimizations to provide more insight and details. For now, a good reference for the sharding strategy is in our video tutorial &lt;a href=&quot;https://www.youtube.com/watch?v=a3iW6Cggccw&amp;amp;list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&amp;amp;index=5&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;If you have questions or find an issue, please find the authors &lt;a href=&quot;https://www.linkedin.com/in/less-wright-22b59017/&quot;&gt;Less&lt;/a&gt;, &lt;a href=&quot;https://www.linkedin.com/in/hamid-nazeri/&quot;&gt;Hamid&lt;/a&gt; and &lt;a href=&quot;https://www.linkedin.com/in/geetachauhan/&quot;&gt;Geeta&lt;/a&gt; or open an issue on&lt;a href=&quot;https://github.com/pytorch/pytorch&quot;&gt; PyTorch github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Special thanks to:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pytorch Distributed team, Shen Li, Rohan Varma, Yanli Zhao, Andrew Gu, Anjali Sridhar, Ana Simoes, Pierre-Yves Aquilanti, Sundar Ranganathan, and the broader AWS team for supporting us with providing infrastructure and technical support for running the large scale experiments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PL_lsbAsL_o2BT6aerEKgIoufVD_fodnuT&quot;&gt;FSDP video series&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://pytorch.org/tutorials/intermediate/FSDP_tutorial.html&quot;&gt;Getting started with FSDP&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://pytorch.org/tutorials/intermediate/FSDP_adavnced_tutorial.html&quot;&gt;Advanced tutorial on FSDP&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://pytorch.org/docs/stable/fsdp.html?highlight=fsdp#module-torch.distributed.fsdp&quot;&gt;API documentation&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;style&gt;

    td{
        border: 1px solid black;
    }
    
    article.pytorch-article table tr td:first-of-type{
        padding: 0.3125rem;
    }

    article.pytorch-article table td {
    padding: 0.3125rem;
    }
}

&lt;/style&gt;</content>

      
      
      
      
      

      <author>
          <name>Less Wright, Hamid Shojanazeri, Geeta Chauhan</name>
        
        
      </author>

      

      

      
        <summary type="html">Cutting-edge AI models are becoming extremely large. The cost and overhead of training these models is increasing rapidly, and involves large amounts of engineering and guesswork to find the right training regime. FSDP reduces these costs significantly by enabling you to train much larger models with the same amount of resources. FSDP lowers the memory footprint on your GPUs, and is usable via a lightweight configuration that requires substantially less effort, typically with just a few lines of code.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Scaling PyTorch FSDP for Training Foundation Models on IBM Cloud</title>
      <link href="https://pytorch.org/blog/scaling-pytorch-fsdp-for-training-foundation-models-on-ibm-cloud/" rel="alternate" type="text/html" title="Scaling PyTorch FSDP for Training Foundation Models on IBM Cloud" />
      <published>2022-12-15T00:00:00-08:00</published>
      <updated>2022-12-15T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/scaling-pytorch-fsdp-for-training-foundation-models-on-ibm-cloud</id>
      <content type="html" xml:base="https://pytorch.org/blog/scaling-pytorch-fsdp-for-training-foundation-models-on-ibm-cloud/">&lt;p&gt;Large model training using a cloud native approach is of growing interest for many enterprises given the emergence and success of &lt;a href=&quot;https://research.ibm.com/blog/what-are-foundation-models&quot;&gt;foundation models&lt;/a&gt;. Some AI practitioners may assume that the only way they can achieve high GPU utilization for distributed training jobs is to run them on HPC systems, such as those inter-connected with Infiniband and may not consider Ethernet connected systems. We demonstrate how the latest distributed training technique, Fully Sharded Data Parallel (FSDP) from PyTorch, successfully scales to models of size 10B+ parameters using commodity Ethernet networking in IBM Cloud.&lt;/p&gt;

&lt;h2 id=&quot;pytorch-fsdp-scaling&quot;&gt;PyTorch FSDP Scaling&lt;/h2&gt;

&lt;p&gt;As models get larger, the standard techniques for data parallel training work only if the GPU can hold a full replica of the model, along with its training state (optimizer, activations, etc.). However, GPU memory increases have not kept up with the model size increases and new techniques for training such models have emerged (e.g., Fully Sharded Data Parallel, &lt;a href=&quot;https://www.deepspeed.ai/&quot;&gt;DeepSpeed&lt;/a&gt;), which allow us to efficiently distribute the model and data over multiple GPUs during training. In this blog post, we demonstrate a path to achieve remarkable scaling of model training to 64 nodes (512 GPUs) using PyTorch native FSDP APIs as we increase model sizes to 11B.&lt;/p&gt;

&lt;h3 id=&quot;what-is-fully-sharded-data-parallel&quot;&gt;What is Fully Sharded Data Parallel?&lt;/h3&gt;

&lt;p&gt;FSDP extends the distributed data parallel training (DDP) approach by sharding model parameters, gradient and optimizer states into K FSDP units, determined by using a wrapping policy. FSDP achieves large model training efficiency in terms of resources and performance by significantly reducing the memory footprint on each GPU and overlapping computation and communication.&lt;/p&gt;

&lt;p&gt;Resource efficiency is achieved with memory footprint reduction by having all GPUs own a portion of each FSDP unit. To process a given FSDP unit, all GPUs share their locally owned portion via all_gather communication calls.&lt;/p&gt;

&lt;p&gt;Performance efficiency is accomplished by overlapping all_gather communication calls for upcoming FSDP units with computation of the current FSDP unit. Once the current FSDP unit has been processed, the non-locally owned parameters are dropped, freeing memory for the upcoming FSDP units.  This process achieves training efficiency by the overlap of computation and communication, while also reducing the peak memory needed by each GPU.&lt;/p&gt;

&lt;p&gt;In what follows, we demonstrate how FSDP allows us to keep hundreds of GPUs highly utilized throughout a distributed training job, while running over standard Ethernet networking (system description towards the end of the blog). We chose the T5 architecture for our experiments and leveraged the code from the &lt;a href=&quot;https://github.com/pytorch/workshops/tree/master/FSDP_Workshop&quot;&gt;FSDP workshop&lt;/a&gt;. In each of our experiments, we start with a single node experiment to create a baseline and report the metric seconds/iteration normalized by the batch size as well as compute the teraflops based on the &lt;a href=&quot;https://cs.stanford.edu/~matei/papers/2021/sc_megatron_lm.pdf&quot;&gt;Megatron-LM paper&lt;/a&gt; (see Appendix for details of teraflop computation for T5). Our experiments aim to maximize the batch size (while avoiding cudaMalloc retries) to take full advantage of overlap in computation and communications, as discussed below. Scaling is defined as the ratio of the seconds/iteration normalized by batch size for N nodes versus a single node, representing how well we can utilize the additional GPUs as more nodes are added.&lt;/p&gt;

&lt;h3 id=&quot;experimental-results&quot;&gt;Experimental Results&lt;/h3&gt;

&lt;p&gt;Our first set of experiments using the T5-3B configuration (mixed precision with BF16, activation checkpointing, and transformer wrapping policy) demonstrated scaling efficiency of 95% as we increased the number of GPUs from 8 to 512 (1 to 64 nodes, respectively). We achieved these results without any modifications to the existing FSDP APIs. We observed that, for this scale, over Ethernet based network, there is sufficient bandwidth to enable continuous overlap of communication and computation.&lt;/p&gt;

&lt;p&gt;However, when we increased the T5 model size to 11B, the scaling efficiency declined substantially to 20%. The PyTorch profiler shows that overlap of communication and computation was very limited. Further investigation into the network bandwidth usage revealed that the poor overlap is being caused by latency in the communication of individual packets and not the bandwidth required (in fact, our peak bandwidth utilization is 1/4th of that available). This led us to hypothesize that if we can increase the compute time by increasing the batch size, we can better overlap communication and computation. However, given we are already at maximum GPU memory allocation, we must identify opportunities to rebalance the memory allocation to allow for increase in batch size. We identified that the model state was being allocated a lot more memory than was needed. The primary function of these reservations is to have pre-reserved memory ready to aggressively send/receive tensors during the communication periods and too few buffers can result in increased wait times, whereas too many buffers result in smaller batch sizes.&lt;/p&gt;

&lt;p&gt;To achieve better efficiency, the PyTorch distributed team introduced a new control knob, the rate_limiter which controls how much memory is allocated for send/receive of tensors, alleviating the memory pressure and providing room for higher batch sizes.  In our case, the rate_limiter could increase the batch size from 20 to 50, thus increasing compute time by 2.5x and allowing for much greater overlap of communication and computation. With this fix, we increased the scaling efficiency to &amp;gt;75% (at 32 nodes)!&lt;/p&gt;

&lt;p&gt;Continued investigation into the factors limiting scaling efficiency uncovered that the rate limiter was creating a recurring pipeline bubble of GPU idle time. This was due to the rate limiter using a block and flush approach for the allocation and release of each set of memory buffers. By waiting for the entire block to complete before initiating a new all_gather, the GPU was idling at the start of each block, while waiting for the new set of all_gather parameters to arrive. This bubble was alleviated by moving to a sliding window approach. Upon the completion of a single all_gather step and its computation (rather than a block of them), the memory is freed and the next all_gather is immediately issued in a much more uniform manner.  This improvement eliminated the pipeline bubble and boosted the scaling efficiencies to &amp;gt;90% (at 32 nodes).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-pytorch-fsdp-image1-IBM_scaling_FSDP_visual_new.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
Figure 1: Scaling of T5-XL (3B) and T5-XXL (11B) from 1 node to 64 nodes
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/scaling-pytorch-fsdp-image2-tflops_per_second_new.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
Figure 2: TFLOPs/sec usage for T5-XL(3B) and T5-XXL (11B) as we increase number of nodes
&lt;/p&gt;

&lt;h2 id=&quot;ibm-cloud-ai-system-and-middleware&quot;&gt;IBM Cloud AI System and Middleware&lt;/h2&gt;

&lt;p&gt;The AI infrastructure used for this work is a large-scale AI system on IBM Cloud consisting of nearly 200 nodes, each node with 8 NVIDIA A100 80GB cards, 96 vCPUs, and 1.2TB CPU RAM. The GPU cards within a node are connected via NVLink with a card-to-card bandwidth of 600GBps. Nodes are connected by 2 x 100Gbps Ethernet links with SRIOV based TCP/IP stack, providing a usable bandwidth of 120Gbps.&lt;/p&gt;

&lt;p&gt;The IBM Cloud AI System has been production-ready since May of 2022 and is configured with the OpenShift container platform to run AI workloads. We also built a software stack for production AI workloads that provide end-to-end tools for training workloads. The middleware leverages Ray for pre and post processing workloads and PyTorch for training of models. We also integrate a Kubernetes native scheduler, MCAD, that manages multiple jobs with job queuing, gang scheduling, prioritization, and quota management. A multi-NIC CNI discovers all available network interfaces and handles them as a single NIC pool enabling optimized use of the network interfaces in Kubernetes. Finally, CodeFlare CLI supports a single pane for observability of the full stack using a desktop CLI (e.g., GPU utilization, application metrics like loss, gradient norm).&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/scaling-pytorch-fsdp-image3-cli-and-dashboard.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
Figure 3: Foundation Model Middleware Stack
&lt;/p&gt;

&lt;h3 id=&quot;conclusion-and-future-work&quot;&gt;Conclusion and Future Work&lt;/h3&gt;

&lt;p&gt;In conclusion, we demonstrated how we can achieve remarkable scaling of FSDP APIs over non-InfiniBand networks. We identified the bottleneck that had limited scaling to less than 20% efficiency for 11B parameter model training.  After identifying the issue, we were able to correct this with a new rate limiter control to ensure a more optimal balance of reserved memory and communication overlap relative to compute time. With this improvement, we were able to achieve 90% scaling efficiency (a 4.5x improvement), at 256 GPUs and 80% at 512 GPUs for training of the 11B parameter model. In addition, the 3B parameter model scales extremely well with 95% efficiency even as we increase the number of GPUs to 512.&lt;/p&gt;

&lt;p&gt;This is a first in the industry to achieve such scaling efficiencies for up to 11B parameter models using Kubernetes with vanilla Ethernet and PyTorch native FSDP API’s. This improvement enables users to train huge models on a Hybrid Cloud platform in a cost efficient and sustainable manner.&lt;/p&gt;

&lt;p&gt;We plan on continuing to investigate scaling with decoder only models and increasing the size of these models to 100B+ parameters. From a system design perspective, we are exploring capabilities such as RoCE and GDR that can improve latencies of communications over Ethernet networks.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;This blog was possible because of contributions from both PyTorch Distributed and IBM Research teams.&lt;/p&gt;

&lt;p&gt;From the PyTorch Distributed team, we would like to thank Less Wright, Hamid Shojanazeri, Geeta Chauhan, Shen Li, Rohan Varma, Yanli Zhao, Andrew Gu, Anjali Sridhar, Chien-Chin Huang, and Bernard Nguyen.&lt;/p&gt;

&lt;p&gt;From the IBM Research team, we would like to thank Linsong Chu, Sophia Wen, Lixiang (Eric) Luo, Marquita Ellis, Davis Wertheimer, Supriyo Chakraborty, Raghu Ganti, Mudhakar Srivatsa, Seetharami Seelam, Carlos Costa, Abhishek Malvankar, Diana Arroyo, Alaa Youssef, Nick Mitchell.&lt;/p&gt;

&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;/h2&gt;

&lt;h4 id=&quot;teraflop-computation&quot;&gt;Teraflop computation&lt;/h4&gt;

&lt;p&gt;The T5-XXL (11B) architecture has two types of T5 blocks, one is an encoder and the second is a decoder. Following the approach of Megatron-LM, where each matrix multiplication requires 2m×k×n FLOPs, where the first matrix is of size m×k and the second is k×n. The encoder block consists of self-attention and feed forward layers, whereas the decoder block consists of self-attention, cross-attention, and feed forward layers.&lt;/p&gt;

&lt;p&gt;The attention (both self and cross) block consists of a QKV projection, which requires 6Bsh&lt;sup&gt;2&lt;/sup&gt; operations, an attention matrix computation requiring 2Bs&lt;sup&gt;2&lt;/sup&gt;h operations, an attention over values which needs 2Bs&lt;sup&gt;2&lt;/sup&gt;h computations, and the post-attention linear projection requires 2Bsh&lt;sup&gt;2&lt;/sup&gt; operations. Finally, the feed forward layer requires 15Bsh&lt;sup&gt;2&lt;/sup&gt; operations.&lt;/p&gt;

&lt;p&gt;The total for an encoder block is 23Bsh&lt;sup&gt;2&lt;/sup&gt;+4Bs&lt;sup&gt;2&lt;/sup&gt;h, whereas for a decoder block, it comes to 31Bsh&lt;sup&gt;2&lt;/sup&gt;+8Bs&lt;sup&gt;2&lt;/sup&gt;h. With a total of 24 encoder and 24 decoder blocks and 2 forward passes (as we discard the activations) and one backward pass (equivalent to two forward passes), the final FLOPs computation comes to be 96×(54Bsh&lt;sup&gt;2&lt;/sup&gt;+ 12Bs&lt;sup&gt;2&lt;/sup&gt;h) + 6BshV. Here, B is the batch size per GPU, s is sequence length, h is hidden state size, and V is vocabulary size. 
We repeat a similar computation for T5-XL (3B) architecture, which is slightly different.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Linsong Chu, Less Wright, Hamid Shojanazeri, Sophia Wen, Raghu Ganti, Geeta Chauhan</name>
        
        
      </author>

      

      

      
        <summary type="html">Large model training using a cloud native approach is of growing interest for many enterprises given the emergence and success of foundation models. Some AI practitioners may assume that the only way they can achieve high GPU utilization for distributed training jobs is to run them on HPC systems, such as those inter-connected with Infiniband and may not consider Ethernet connected systems. We demonstrate how the latest distributed training technique, Fully Sharded Data Parallel (FSDP) from PyTorch, successfully scales to models of size 10B+ parameters using commodity Ethernet networking in IBM Cloud.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Accelerating Hugging Face and TIMM models with PyTorch 2.0</title>
      <link href="https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/" rel="alternate" type="text/html" title="Accelerating Hugging Face and TIMM models with PyTorch 2.0" />
      <published>2022-12-02T00:00:00-08:00</published>
      <updated>2022-12-02T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models</id>
      <content type="html" xml:base="https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/">&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile()&lt;/code&gt; makes it easy to experiment with different compiler backends to make PyTorch code faster with a single line decorator &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile()&lt;/code&gt;. It works either directly over an nn.Module as a drop-in replacement for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.jit.script()&lt;/code&gt; but without requiring you to make any source code changes. We expect this one line code change to provide you with between 30%-2x training time speedups on the vast majority of models that you’re already running.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;opt_module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;torch.compile supports arbitrary PyTorch code, control flow, mutation and comes with experimental support for dynamic shapes. We’re so excited about this development that we call it PyTorch 2.0.&lt;/p&gt;

&lt;p&gt;What makes this announcement different for us is we’ve already benchmarked some of the most popular open source PyTorch models and gotten substantial speedups ranging from 30% to 2x &lt;a href=&quot;https://github.com/pytorch/torchdynamo/issues/681&quot;&gt;https://github.com/pytorch/torchdynamo/issues/681&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are no tricks here, we’ve pip installed popular libraries like &lt;a href=&quot;https://github.com/huggingface/transformers&quot;&gt;https://github.com/huggingface/transformers&lt;/a&gt;, &lt;a href=&quot;https://github.com/huggingface/accelerate&quot;&gt;https://github.com/huggingface/accelerate&lt;/a&gt; and &lt;a href=&quot;https://github.com/rwightman/pytorch-image-models&quot;&gt;https://github.com/rwightman/pytorch-image-models&lt;/a&gt; and then ran torch.compile() on them and that’s it.&lt;/p&gt;

&lt;p&gt;It’s rare to get both performance and convenience, but this is why the core team finds PyTorch 2.0 so exciting. The Hugging Face team is also excited, in their words:&lt;/p&gt;

&lt;p&gt;Ross Wightman the primary maintainer of TIMM: “PT 2.0 works out of the box with majority of timm models for inference and train workloads and no code changes”&lt;/p&gt;

&lt;p&gt;Sylvain Gugger the primary maintainer of transformers and accelerate: “With just one line of code to add, PyTorch 2.0 gives a speedup between 1.5x and 2.x in training Transformers models. This is the most exciting thing since mixed precision training was introduced!”&lt;/p&gt;

&lt;p&gt;This tutorial will show you exactly how to replicate those speedups so you can be as excited as to PyTorch 2.0 as we are.&lt;/p&gt;

&lt;h2 id=&quot;requirements-and-setup&quot;&gt;Requirements and Setup&lt;/h2&gt;

&lt;p&gt;For GPU (newer generation GPUs will see drastically better performance)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install numpy --pre torch --force-reinstall --extra-index-url https://download.pytorch.org/whl/nightly/cu117

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For CPU&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install --pre torch --extra-index-url https://download.pytorch.org/whl/nightly/cpu

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optional: Verify Installation&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/pytorch/pytorch
cd tools/dynamo
python verify_dynamo.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optional: Docker installation&lt;/p&gt;

&lt;p&gt;We also provide all the required dependencies in the PyTorch nightly
binaries which you can download with&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull ghcr.io/pytorch/pytorch-nightly

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And for ad hoc experiments just make sure that your container has access
to all your GPUs&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --gpus all -it ghcr.io/pytorch/pytorch-nightly:latest /bin/bash

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting started&lt;/h2&gt;

&lt;h3 id=&quot;a-toy-exmaple&quot;&gt;a toy exmaple&lt;/h3&gt;

&lt;p&gt;Let’s start with a simple example and make things more complicated step
by step. Please note that you’re likely to see more significant speedups the newer your GPU is.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;new_fn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;inductor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;input_tensor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cuda:0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This example won’t actually run faster but it’s educational.&lt;/p&gt;

&lt;p&gt;example that features &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.cos()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.sin()&lt;/code&gt; which are examples of pointwise ops as in they operate element by element on a vector. A more famous pointwise op you might actually want to use would be something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.relu()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Pointwise ops in eager mode are suboptimal because each one would need to read a tensor from memory, make some changes and then write back those changes.&lt;/p&gt;

&lt;p&gt;The single most important optimization that PyTorch 2.0 does for you is fusion.&lt;/p&gt;

&lt;p&gt;So back to our example we can turn 2 reads and 2 writes into 1 read and 1 write which is crucial especially for newer GPUs where the bottleneck is memory bandwidth (how quickly you can send data to a GPU) instead of compute (how quickly your GPU can crunch floating point operations)&lt;/p&gt;

&lt;p&gt;The second most important optimization that PyTorch 2.0 does for you is CUDA graphs&lt;/p&gt;

&lt;p&gt;CUDA graphs help eliminate the overhead from launching individual kernels from a python program.&lt;/p&gt;

&lt;p&gt;torch.compile() supports many different backends but one that we’re particularly excited about is Inductor which generates Triton kernels &lt;a href=&quot;https://github.com/openai/triton&quot;&gt;https://github.com/openai/triton&lt;/a&gt; which are written in Python yet outperform the vast majority of handwritten CUDA kernels. Suppose our example above was called trig.py we can actually inspect the code generated triton kernels by running.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TORCH_COMPILE_DEBUG=1 python trig.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointwise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size_hints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__file__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'signature'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'*fp32'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'*fp32'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'i32'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'device'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'constants'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'configs'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance_descriptor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;divisible_by_16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;equal_to_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())]})&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;triton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jit&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in_ptr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out_ptr0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xnumel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XBLOCK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constexpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xnumel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xoffset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;program_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XBLOCK&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xindex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xoffset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reshape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;XBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xindex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xnumel&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xindex&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in_ptr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmp2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out_ptr0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XBLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And you can verify that fusing the two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sins&lt;/code&gt; did actually occur because the two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sin&lt;/code&gt; operations occur within a single Triton kernel and the temporary variables are held in registers with very fast access.&lt;/p&gt;

&lt;h3 id=&quot;a-real-model&quot;&gt;a real model&lt;/h3&gt;

&lt;p&gt;As a next step let’s try a real model like resnet50 from the PyTorch hub.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pytorch/vision:v0.10.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'resnet18'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pretrained&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;opt_model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;inductor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you actually run you may be surprised that the first run is slow and that’s because the model is being compiled. Subsequent runs will be faster so it’s common practice to warm up your model before you start benchmarking it.&lt;/p&gt;

&lt;p&gt;You may have noticed how we also passed in the name of a compiler explicitly here with “inductor” but it’s not the only available backend, you can run in a REPL &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch._dynamo.list_backends()&lt;/code&gt; to see the full list of available backends. For fun you should try out &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aot_cudagraphs&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvfuser&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;hugging-face-models&quot;&gt;Hugging Face models&lt;/h3&gt;

&lt;p&gt;Let’s do something a bit more interesting now, our community frequently
uses pretrained models from transformers &lt;a href=&quot;https://github.com/huggingface/transformers&quot;&gt;https://github.com/huggingface/transformers&lt;/a&gt; or TIMM &lt;a href=&quot;https://github.com/rwightman/pytorch-image-models&quot;&gt;https://github.com/rwightman/pytorch-image-models&lt;/a&gt; and one of our design goals for PyTorch 2.0 was that any new compiler stack needs to work out of the box with the vast majority of models people actually run.&lt;/p&gt;

&lt;p&gt;So we’re going to directly download a pretrained model from the Hugging Face hub and optimize it&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;transformers&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BertTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BertModel&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Copy pasted from here https://huggingface.co/bert-base-uncased
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokenizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BertTokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_pretrained&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'bert-base-uncased'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BertModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_pretrained&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bert-base-uncased&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cuda:0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# This is the only line of code that we changed
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Replace me by any text you'd like.&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoded_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_tensors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'pt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cuda:0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoded_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you remove the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to(device=&quot;cuda:0&quot;)&lt;/code&gt; from the model and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encoded_input&lt;/code&gt; then PyTorch 2.0 will generate C++ kernels that will be optimized for running on your CPU. You can inspect both Triton or C++ kernels for BERT, they’re obviously more complex than the trigonometry example we had above but you can similarly skim it and understand if you understand PyTorch.&lt;/p&gt;

&lt;p&gt;The same code also works just fine if used with &lt;a href=&quot;https://github.com/huggingface/accelerate&quot;&gt;https://github.com/huggingface/accelerate&lt;/a&gt; and DDP&lt;/p&gt;

&lt;p&gt;Similarly let’s try out a TIMM example&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;timm&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;create_model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'resnext101_32x8d'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pretrained&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_classes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;opt_model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;inductor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;opt_model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our goal with PyTorch was to build a breadth-first compiler that would speed up the vast majority of actual models people run in open source. The Hugging Face Hub ended up being an extremely valuable benchmarking tool for us, ensuring that any optimization we work on actually helps accelerate models people want to run.&lt;/p&gt;

&lt;p&gt;So please try out PyTorch 2.0, enjoy the free perf and if you’re not seeing it then please open an issue and we will make sure your model is supported &lt;a href=&quot;https://github.com/pytorch/torchdynamo/issues&quot;&gt;https://github.com/pytorch/torchdynamo/issues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After all, we can’t claim we’re created a breadth-first unless YOUR models actually run faster.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Mark Saroufim</name>
        
        
      </author>

      

      

      
        <summary type="html">torch.compile() makes it easy to experiment with different compiler backends to make PyTorch code faster with a single line decorator torch.compile(). It works either directly over an nn.Module as a drop-in replacement for torch.jit.script() but without requiring you to make any source code changes. We expect this one line code change to provide you with between 30%-2x training time speedups on the vast majority of models that you’re already running.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Get Started with PyTorch 2.0 Summary and Overview</title>
      <link href="https://pytorch.org/blog/getting-started-with-pytorch-2.0/" rel="alternate" type="text/html" title="Get Started with PyTorch 2.0 Summary and Overview" />
      <published>2022-12-02T00:00:00-08:00</published>
      <updated>2022-12-02T00:00:00-08:00</updated>
      <id>https://pytorch.org/blog/getting-started-with-pytorch-2.0</id>
      <content type="html" xml:base="https://pytorch.org/blog/getting-started-with-pytorch-2.0/">&lt;p&gt;Introducing PyTorch 2.0, our first steps toward the next generation 2-series release of PyTorch. Over the last few years we have innovated and iterated from PyTorch 1.0 to the most recent 1.13 and moved to the newly formed PyTorch Foundation, part of the Linux Foundation.&lt;/p&gt;

&lt;p&gt;To complement the PyTorch 2.0 announcement and conference, we have also posted a comprehensive introduction and technical overview within the Get Started menu at &lt;a href=&quot;https://pytorch.org/get-started/pytorch-2.0&quot;&gt;https://pytorch.org/get-started/pytorch-2.0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We also wanted to ensure you had all the information to quickly leverage PyTorch 2.0 in your models so we added the technical requirements, tutorial, user experience, Hugging Face benchmarks and FAQs to get you started today!&lt;/p&gt;

&lt;p&gt;Finally we are launching a new “Ask the Engineers: 2.0 Live Q&amp;amp;A” series that allows you to go deeper on a range of topics with PyTorch subject matter experts. We hope this content is helpful for the entire community and level of users/contributors.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pytorch.org/get-started/pytorch-2.0&quot;&gt;https://pytorch.org/get-started/pytorch-2.0&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Team PyTorch</name>
        
        
      </author>

      

      

      
        <summary type="html">Introducing PyTorch 2.0, our first steps toward the next generation 2-series release of PyTorch. Over the last few years we have innovated and iterated from PyTorch 1.0 to the most recent 1.13 and moved to the newly formed PyTorch Foundation, part of the Linux Foundation.</summary>
      

      
      
    </entry>
  
</feed>


